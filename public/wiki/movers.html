<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0069)https://wiki.rosettacommons.org/index.php/Movers_%28RosettaScripts%29 -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Movers (RosettaScripts) - RosettaWiki</title>
<meta name="KEYWORDS" content="Movers (RosettaScripts),TaskOperations (RosettaScripts),FeaturesScientificBenchmark,FeaturesDatabaseSchema,FeaturesTutorialSQLBasics,MetropolisHastingsMover,MetropolisHastings Documentation,DatabaseSupport">

<meta name="robots" content="index,follow">
<link rel="shortcut icon" href="https://wiki.rosettacommons.org/favicon.ico">
<link rel="stylesheet" type="text/css" media="print" href="./movers_files/wikiprintable.css">
<script type="text/javascript" src="./movers_files/wikibits.js"></script>
<style type="text/css">
/*/*/
@import "/stylesheets/wikistandard.css";
a.new, #quickbar a.new { color: #CC2200; }
#quickbar { position: absolute; top: 4px; left: 4px; border-right: 1px solid gray; }
#article { margin-left: 152px; margin-right: 4px; }

/* */
</style>
</head>

<body bgcolor="#FFFFFF" onload="">

<div id="content">

<div id="article">
<h1 class="pagetitle">Movers (RosettaScripts)</h1>
<p>Each mover definition has the following structure
</p>
<pre style="white-space:pre-wrap">&lt;"mover_name" name="&amp;string" .../&gt;</pre>
<p>where "mover_name" belongs to a predefined set of possible movers that the parser recognizes and are listed below, name is a unique identifier for this mover definition and then any number of parameters that the mover needs to be defined.
</p>
<table border="0" id="toc"><tbody><tr id="toctitle"><td align="center">
<b>Table of contents</b> 
</td></tr><tr id="tocinside"><td>
<div class="tocline"><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Mover_Documentation_Guide">1 Mover Documentation Guide</a><br></div>
<div class="tocline"><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Predefined_Movers">2 Predefined Movers</a><br></div>
<div class="tocindent">
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#NullMover">2.1 NullMover</a><br>
</p>
</div>
</div>
<div class="tocline"><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Special_Movers">3 Special Movers</a><br></div>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Combining_Movers">3.1 Combining Movers</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#ParsedProtocol_.28formerly_DockDesign.29">3.1.1 ParsedProtocol (formerly DockDesign)</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Subroutine">3.1.2 Subroutine</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#IfMover">3.1.3 IfMover</a><br>
</p>
</div>
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Looping.2FMonte_Carlo_Movers">3.2 Looping/Monte Carlo Movers</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#LoopOver">3.2.1 LoopOver</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#GenericMonteCarlo">3.2.2 GenericMonteCarlo</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#MonteCarloTest">3.2.3 MonteCarloTest</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#MonteCarloRecover">3.2.4 MonteCarloRecover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#MonteCarloUtil">3.2.5 MonteCarloUtil</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#MetropolisHastings">3.2.6 MetropolisHastings</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#IteratedConvergence">3.2.7 IteratedConvergence</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#RampMover">3.2.8 RampMover</a><br>
</p>
</div>
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Reporting.2FSaving">3.3 Reporting/Saving</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#ReportToDB">3.3.1 ReportToDB</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#DumpPdb">3.3.2 DumpPdb</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#PDBTrajectoryRecorder">3.3.3 PDBTrajectoryRecorder</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#SilentTrajectoryRecorder">3.3.4 SilentTrajectoryRecorder</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#MetricRecorder">3.3.5 MetricRecorder</a><br>
</p>
</div>
</div>
<div class="tocline"><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#General_Movers">4 General Movers</a><br></div>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Packing.2FMinimization">4.1 Packing/Minimization</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#PackRotamersMover">4.1.1 PackRotamersMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#MinMover">4.1.2 MinMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#TaskAwareMinMover">4.1.3 TaskAwareMinMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#MinPackMover">4.1.4 MinPackMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Sidechain">4.1.5 Sidechain</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#SidechainMC">4.1.6 SidechainMC</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#RotamerTrialsMover">4.1.7 RotamerTrialsMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#RotamerTrialsMinMover">4.1.8 RotamerTrialsMinMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#ConsensusDesignMover">4.1.9 ConsensusDesignMover</a><br>
</p>
</div>
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Idealize.2FRelax">4.2 Idealize/Relax</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Idealize">4.2.1 Idealize</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#FastRelax">4.2.2 FastRelax</a><br>
</p>
</div>
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Docking.2FAssembly">4.3 Docking/Assembly</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#DockingProtocol">4.3.1 DockingProtocol</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#FlexPepDock">4.3.2 FlexPepDock</a><br>
</p>
</div>
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Backbone_Movement">4.4 Backbone Movement</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#SetTorsion">4.4.1 SetTorsion</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Shear">4.4.2 Shear</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Small">4.4.3 Small</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Backrub">4.4.4 Backrub</a><br>
</p>
</div>
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Constraints">4.5 Constraints</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#ConstraintSetMover">4.5.1 ConstraintSetMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#TaskAwareCsts">4.5.2 TaskAwareCsts</a><br>
</p>
</div>
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Fragment_Insertion">4.6 Fragment Insertion</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#SingleFragmentMover">4.6.1 SingleFragmentMover</a><br>
</p>
</div>
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Symmetry">4.7 Symmetry</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#SetupForSymmetry">4.7.1 SetupForSymmetry</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#ExtractAsymmetricUnit">4.7.2 ExtractAsymmetricUnit</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#ExtractAsymmetricPose">4.7.3 ExtractAsymmetricPose</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#SymPackRotamersMover_and_SymRotamerTrialsMover">4.7.4 SymPackRotamersMover and SymRotamerTrialsMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#SymMinMover">4.7.5 SymMinMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Example:_Symmetric_FastRelax">4.7.6 Example: Symmetric FastRelax</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Issues_with_Symmetry_and_Rosetta_Scripts">4.7.7 Issues with Symmetry and Rosetta Scripts</a><br>
</p>
</div>
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Other_Pose_Manipulation">4.8 Other Pose Manipulation</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#AddChainBreak">4.8.1 AddChainBreak</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#FoldTreeFromLoops">4.8.2 FoldTreeFromLoops</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#LoopLengthChange">4.8.3 LoopLengthChange</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#MakePolyX">4.8.4 MakePolyX</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#MembraneTopology">4.8.5 MembraneTopology</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#SwitchResidueTypeSetMover">4.8.6 SwitchResidueTypeSetMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#FavorNativeResidue">4.8.7 FavorNativeResidue</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#FavorSequenceProfile">4.8.8 FavorSequenceProfile</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#SetTemperatureFactor">4.8.9 SetTemperatureFactor</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#RollMover">4.8.10 RollMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#RemodelMover">4.8.11 RemodelMover</a><br>
</p>
</div>
</div>
<div class="tocline"><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Protein_Interface_Design_Movers">5 Protein Interface Design Movers</a><br></div>
<div class="tocindent">
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#ProteinInterfaceMS">5.1 ProteinInterfaceMS</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#InterfaceAnalyzerMover">5.2 InterfaceAnalyzerMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Docking">5.3 Docking</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Prepack">5.4 Prepack</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#RepackMinimize">5.5 RepackMinimize</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#DesignMinimizeHBonds">5.6 DesignMinimizeHBonds</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#build_Ala_pose">5.7 build_Ala_pose</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#SaveAndRetrieveSidechains">5.8 SaveAndRetrieveSidechains</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#AtomTree">5.9 AtomTree</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#SpinMover">5.10 SpinMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#TryRotamers">5.11 TryRotamers</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#BackrubDD">5.12 BackrubDD</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#BestHotspotCst">5.13 BestHotspotCst</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#DomainAssembly_.28Not_tested_thoroughly.29">5.14 DomainAssembly (Not tested thoroughly)</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#LoopFinder">5.15 LoopFinder</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#LoopRemodel">5.16 LoopRemodel</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#LoopMoverFromCommandLine">5.17 LoopMoverFromCommandLine</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#DisulfideMover">5.18 DisulfideMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#MutateResidue">5.19 MutateResidue</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#InterfaceRecapitulation">5.20 InterfaceRecapitulation</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#VLB_.28aka_Variable_Length_Build.29">5.21 VLB (aka Variable Length Build)</a><br>
</p>
</div>
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Computational_.27affinity_maturation.27_movers_.28highly_experimental.29">5.1 Computational 'affinity maturation' movers (highly experimental)</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#RandomMutation">5.1.1 RandomMutation</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#GreedyOptMutationMover">5.1.2 GreedyOptMutationMover</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#HotspotDisjointedFoldTree">5.1.3 HotspotDisjointedFoldTree</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#AddSidechainConstraintsToHotspots">5.1.4 AddSidechainConstraintsToHotspots</a><br>
</p>
</div>
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Placement_and_Placement-associated_Movers_.26_Filters">5.2 Placement and Placement-associated Movers &amp; Filters</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Auction">5.2.1 Auction</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#MapHotspot">5.2.2 MapHotspot</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#PlacementMinimization">5.2.3 PlacementMinimization</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#PlaceOnLoop">5.2.4 PlaceOnLoop</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#PlaceStub">5.2.5 PlaceStub</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#PlaceSimultaneously">5.2.6 PlaceSimultaneously</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#StubScore">5.2.7 StubScore</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#ddG">5.2.8 ddG</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#ContactMap">5.2.9 ContactMap</a><br>
</p>
</div>
</div>
<div class="tocline"><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Ligand-centric_Movers">6 Ligand-centric Movers</a><br></div>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Ligand_docking">6.1 Ligand docking</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#StartFrom">6.1.1 StartFrom</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Translate">6.1.2 Translate</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Rotate">6.1.3 Rotate</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#SlideTogether">6.1.4 SlideTogether</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#HighResDocker">6.1.5 HighResDocker</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#FinalMinimizer">6.1.6 FinalMinimizer</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#InterfaceScoreCalculator">6.1.7 InterfaceScoreCalculator</a><br>
</p>
</div>
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Enzyme_design">6.2 Enzyme design</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#EnzRepackMinimize">6.2.1 EnzRepackMinimize</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#AddOrRemoveMatchCsts">6.2.2 AddOrRemoveMatchCsts</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#PredesignPerturbMover">6.2.3 PredesignPerturbMover</a><br>
</p>
</div>
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Ligand_design">6.3 Ligand design</a><br>
</p>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#GrowLigand">6.3.1 GrowLigand</a><br>
<a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#AddHydrogens">6.3.2 AddHydrogens</a><br>
</p>
</div>
</div>
<div class="tocline"><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#DNA_interface_Design_Movers">7 DNA interface Design Movers</a><br></div>
<div class="tocindent">
<p><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#DnaInterfacePacker">7.1 DnaInterfacePacker</a><br>
</p>
</div>
<div class="tocline"><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#Currently_Undocumented">8 Currently Undocumented</a><br></div>
</td></tr></tbody></table>
<a name="Mover_Documentation_Guide"></a><h2>Mover Documentation Guide</h2>
<p>Since RosettaScripts allows you to put Movers together in ways that have not been tried before there are a few things you <strong>NEED</strong> to answer when documenting your mover:
</p>
<ul><li> General description of what the mover does
<ul><li>Example: This is meant as an example of how to construct a Mover in RosettaScripts and how to describe all of the options that it takes. This outline was decided upon at Post-RosettaCon11-Minicon.
</li></ul>
</li><li> XML code example:
</li></ul>
<pre style="white-space:pre-wrap">&lt;MyMover name="&amp;string" bool_option=(1 &amp;bool) int_option=(50 &amp;int) string_option=(&amp;string) real_option=(2.2 &amp;Real) scorefxn=(default_scorefxn &amp;string) task_operations=(&amp;string,&amp;string,&amp;string)/&gt;)</pre>
<ul><li> What the tags do:
<ul><li> <strong>bool_option</strong> describes how a boolean tag is made.  Default is true.
</li><li> <strong>int_option</strong> describes how an integer tag is made.  Let's say this represents # of cycles of a loop to run, so the range would have to be &gt; 0.
</li><li> <strong>real_option</strong> describes how to a Real option tag is made.
</li><li> <strong>string_option</strong> is an example of how a string tag is made. 
</li></ul>
</li><li> What options must be provided?
<ul><li>For example let's say that we need to pass a value to string_option or the protocol will not not run, you would include something like this:
</li><li> string_option="/path/to/some/file" needs to be defined to avoid mover exit.
</li></ul>
</li><li> Expected input type:
<ul><li> Does this mover expect a certain kind of pose (protein/DNA, 2 chains, monomer)
</li></ul>
</li><li> Internal TaskOperations:
<ul><li>Are there default TaskOperations (RestrictToInterface for example) that this mover uses, is there a way to override them?
</li></ul>
</li><li> FoldTree / Constraint changes:
<ul><li> Describe if/how the mover modifies the input (or default) FoldTree or Constraints
</li></ul>
</li><li> If the mover can change the length of the pose say so.
</li></ul>
<a name="Predefined_Movers"></a><h2>Predefined Movers</h2>
<p>The following are defined internally in the parser, and the protocol can use them without defining them explicitly. 
</p>
<a name="NullMover"></a><h4>NullMover</h4>
<p>Has an empty apply. Will be used as the default mover in &lt;PROTOCOLS&gt; if no mover_name is specified. Can be explicitly specified, with the name "null".
</p>
<a name="Special_Movers"></a><h2>Special Movers</h2>
<a name="Combining_Movers"></a><h3>Combining Movers</h3>
<a name="ParsedProtocol_.28formerly_DockDesign.29"></a><h4>ParsedProtocol (formerly DockDesign)</h4>
<p>This is a special mover that allows making a single compound mover and filter vector (just like protocols). The optional option mode changes the order of operations within the protocol, as defined by the option. If undefined, mode defaults to the historical functionality, which is operation of the Mover/Filter pairs in the defined order.
</p>
<pre style="white-space:pre-wrap">&lt;ParsedProtocol name=( &amp;string) mode=( &amp;string)&gt;
	&lt;Add mover_name=( null &amp;string) filter_name=( true_filter &amp;string) apply_probabilities=(see below &amp;Real/&gt;
	...
&lt;/ParsedProtocol&gt;
</pre>
<ul>
<li>mode: "sequence" - (default) perform the Mover/Filter pair in the specified sequence; "random_order" - perform EACH of the defined Mover/Filter pairs one time in a random order; "single_random" - randomly pick a SINGLE Mover/Filter pair from the list.
</li><li> apply_probabilities: This only works in mode single_random. You can set the probability that an individual submover will be called 0-1. The probabilities must sum to 1.0, or you'll get an error message. Notice that this is used by GenericMonteCarlo in its adaptive_movers mode to adjust the probabilities of movers dynamically during a sampling trajectory. 
</li></ul>
<a name="Subroutine"></a><h4>Subroutine</h4>
<p>Calling another RosettaScript from within a RosettaScript
</p>
<pre style="white-space:pre-wrap">&lt;Subroutine name=(&amp;string) xml_fname=(&amp;string)/&gt;</pre>
<ul>
<li> xml_fname: the name of the RosettaScript to call.
</li></ul>
<p>This definition in effect generates a Mover that can then be incorporated into the RosettaScripts PROTOCOLS section. This allows a simplification and modularization of RosettaScripts. 
</p><p>Recursions are allowed but will cause havoc.
</p>
<a name="IfMover"></a><h4>IfMover</h4>
<p>Implements a simple IF (filter(pose)) THEN true_mover(pose) ELSE false_mover(pose). <em>true_mover</em> is required, <em>false_mover</em> is not. 
</p>
<pre style="white-space:pre-wrap">&lt;If name=( &amp;string) filter_name=(&amp;string) true_mover_name=(&amp;string) false_mover_name=(null &amp;string)/&gt;
</pre>
<a name="Looping.2FMonte_Carlo_Movers"></a><h3>Looping/Monte Carlo Movers</h3>
<a name="LoopOver"></a><h4>LoopOver</h4>
<p>Allows looping over a mover using either iterations or a filter as a stopping condition (the first turns true). By using DockDesign mover above with loop can be useful, e.g., if making certain moves is expensive and then we want to exhaust other, shorter moves. 
</p>
<pre style="white-space:pre-wrap">&lt;LoopOver name=(&amp;string) mover_name=(&amp;string) filter_name=( false_filter &amp;string) iterations=(10 &amp;Integer) drift=(true &amp;bool)/&gt;</pre>
<p>drift: true- the state of the pose at the end of the previous iteration will be the starting state for the next iteration.
false- the state of the pose at the start of each iteration will be reset to the state when the mover is first called. 
Note that "falling off the end" of the iteration will revert to the original input pose, even if drift is set to true. 
</p><p>This mover is somewhat deprecated in favor of the more general GenericMonteCarlo mover.
</p>
<a name="GenericMonteCarlo"></a><h4>GenericMonteCarlo</h4>
<p>Allows sampling structures by MonteCarlo with a mover. The score evaluation of pose during MC are done by Filters that can do report_sm(), not only ScoreFunctions.<br>
You can choose either format:
</p><p>1) scoring by Filters
</p>
<pre style="white-space:pre-wrap">&lt;GenericMonteCarlo name=(&amp;string) mover_name=(&amp;string) filter_name=(&amp;string) trials=(10 &amp;integer) sample_type=(low, &amp;string) temperature=(0, &amp;Real) drift=(1 &amp;bool) recover_low=(1 &amp;bool) boltz_rank=(0 &amp;bool) stopping_condition=(FalseFilter &amp;string) preapply=(1 &amp;bool) adaptive_movers=(0 &amp;bool) adaptation_period=(see below &amp;integer)&gt;
  &lt;Filters&gt;
     &lt;AND filter_name=(&amp;string) temperature=(&amp;Real) sample_type=(low, &amp;string) rank=(0 &amp;bool)/&gt;
     ...
  &lt;/Filters&gt;
&lt;/GenericMonteCarlo&gt;
</pre>
<p>2) scoring by ScoreFunction
</p>
<pre style="white-space:pre-wrap">&lt;GenericMonteCarlo name=(&amp;string) mover_name=(&amp;string) scorefxn_name=(&amp;string) trials=(10 &amp;integer) sample_type=(low, &amp;string) temperature=(0, &amp;Real) drift=(1 &amp;bool) recover_low=(1 &amp;bool) stopping_condition=(FalseFilter &amp;string) preapply=(1 &amp;bool)/&gt;</pre>
<ul>
<li><em>stopping_condition</em>: stops before trials are done if a filter evaluates to true.<br>
</li><li><em>sample_type</em>: low - sampling structures having lower scores; high - sampling structures having higher scores<br> 
</li><li><em>drift</em>: true - the state of the pose at the end of the previous iteration will be the starting state for the next iteration; false - the state of the pose at the start of each iteration will be reset to the state when the mover is first called ( Of course, this is not MC ).<br>
</li><li><em>recover_low</em>: true - at the end of application, the pose is set to the lowest (or highest if sample_type="high") scoring pose; false - the pose after apply completes is the last accepted pose<br>
</li><li><em>preapply</em>: true - Automatically accept the first application of the sub-mover, ignoring the Boltzmann criterion. false - apply Boltzmann accept/reject to all applications of the mover. Though defaulting to true for historical reasons, it is highly recommended to set this to false unless you know you need it to be true.<br>
</li><li> adaptive_movers: If the mover you call or a submover of that mover is of type ParsedProtocol with mode single-random, then GenericMonteCarlo can 'learn' the best sampling strategy by adapting the apply probabilities of individual movers within that ParsedProtocol. For each adaptation period (say 20 mover applies) the number of accepts of each submover is recorded (with pseudocounts of 1 for each mover) and during the next adaptation period the apply probabilities of the submovers in the ParsedProtocol are adjusted according in proportion to the acceptance probabilities of the previous stage. Due to the pseudocounts, all movers have at least some chance of being called.
</li><li> adaptation_period: goes together with adaptive_movers, defined above. Defaults to max( max_trials/10, 10 ) but can be set to any integer.
</li></ul>
<p>Multiple filters can be defined for an MC mover. These filters are then applied sequentially in the order listed and only if the pose passes the Metropolis criterion for all filters is it accepted. This allows the extension of MC to a multicriterion framework where more than one criterion is optimized, say the total score and the binding energy. See demos/rosetta_scripts/experimental/computational_affinity_maturation_strategy2 for an example. It's recommended to list the computationally expensive filters last, as later filters will only be calculated if the earlier filters all pass. 
</p><p>In the multiple filter case, the filter to be used for the official score of the pose (e.g. for recover_low purposes) can be specified with the <em>rank</em> parameter (this has no effect on the MC accept/reject). If no sub-filters are set with rank=1, the first filter is used for ranking. As a special case, if <em>boltz_rank</em> is set to true, the ranking score is a temperature-weighted sum of all filter values. (This value is equivalent to the effective value optimized by the MC protocol.)
</p><p>A task can optionally be included for automatic setting of the number of trials in a GenericMonteCarlo run. Without a task input the number of trials is set by the Trials integer input. If a task is included, the number of designable residues will be calculated and the number of trials will be automatically set as task_scaling * (number designable residues). For example, if there are 10 designable residues and task_scaling is 5 (the default) the number of trials will be 50. The task_scaling is set to 5 by default and can be adjusted in the xml with the task_scaling flag. Giving an input task will override any value set by the Trials input. This allows for automation over a number of different input files. Input the task as for any other move, see example xml line below. Note that the input task does not alter the movers/filters contained within the GenericMonteCarlo, it is only used for calculating the number of designable residues.
</p>
<pre style="white-space:pre-wrap">&lt;GenericMonteCarlo name=(&amp;string) mover_name=(&amp;string) filter_name=(&amp;string) trials=(10 &amp;integer) sample_type=(low, &amp;string) temperature=(0, &amp;Real) drift=(1 &amp;bool) recover_low=(1 &amp;bool) boltz_rank=(0 &amp;bool) stopping_condition=(FalseFilter &amp;string) preapply=(1 &amp;bool) task_operations=(&amp;string,&amp;string,&amp;string) task_scaling=(5 &amp;integer)&gt;

</pre>
<a name="MonteCarloTest"></a><h4>MonteCarloTest</h4>
<p>Associated with GenericMonteCarlo. Simply test the MC criterion of the specified GenericMonteCarloMover and save the current pose if accept.
</p>
<pre style="white-space:pre-wrap">&lt;MonteCarloTest name=(&amp;string) MC_name=(&amp;string)/&gt;</pre>
<ul>
<li> MC_name: name of a previously defined GenericMonteCarloMover
</li></ul>
<p>Useful in conjunction with MonteCarloRecover (below) if you're running a trajectory consisting of many different sorts of movers, and would like at each point to decide whether the pose has made an improvement.
</p>
<a name="MonteCarloRecover"></a><h4>MonteCarloRecover</h4>
<p>Associated with GenericMonteCarlo and MonteCarloTest. Recover a pose from a GenericMonteCarloMover.
</p>
<pre style="white-space:pre-wrap">&lt;MonteCarloRecover name=(&amp;string) MC_name=(&amp;string) recover_low=(1 &amp;bool)/&gt;</pre>
<ul>
<li> MC_name: name of a previously defined GenericMonteCarloMover
</li><li> recover_low: recover the lowest-energy pose, or the last pose.
</li></ul>
<p>Useful in conjunction with MonteCarloRecover (below) if you're running a trajectory consisting of many different sorts of movers, and would like at each point to decide whether the pose has made an improvement.
</p>
<a name="MonteCarloUtil"></a><h4>MonteCarloUtil</h4>
<p>This mover takes as input the name of a montecarlo object specified by the user, and calls the reset or recover_low function on it.
</p>
<pre style="white-space:pre-wrap">&lt;MonteCarloUtil name=(&amp;string) mode=(&amp;string) montecarlo=(&amp;string)/&gt;</pre>
<ul>
<li> mode: Mode of the monte carlo mover.  can be either "reset" or "recover_low"
</li><li>montecarlo: the monte carlo object to act on
</li></ul>
<a name="MetropolisHastings"></a><h4>MetropolisHastings</h4>
<p>This mover performs <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/MetropolisHastingsMover" title="MetropolisHastingsMover">Metropolis-Hastings Monte Carlo simulations</a>, which can be used to estimate the thermodynamic distribution of conformational states for a given score function, temperature, and set of underlying movers. See the dedicated <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/MetropolisHastings_Documentation" title="MetropolisHastings Documentation">MetropolisHastings Documentation</a> page for more information.
</p>
<pre style="white-space:pre-wrap">&lt;MetropolisHastings name=(&amp;string) scorefxn=(score12 &amp;string) temperature=(0.6 &amp;Real) trials=(1000 &amp;Size)&gt;
  ...
&lt;/MetropolisHastings&gt;</pre>
<p>The MetropolisHastings mover uses submovers to perform the trial moves and optionally record statistics about the simulation after each trial. They can be specified in one of two ways:
</p><p></p><ol>
<p></p>
<li>Defining the movers within MetropolisHastings:

<pre style="white-space:pre-wrap">&lt;MetropolisHastings ...&gt;
  &lt;Backrub sampling_weight=(1 &amp;Real) .../&gt;
&lt;/MetropolisHastings&gt;</pre>
</li><li>Referencing previously defined movers:

<pre style="white-space:pre-wrap">&lt;Backrub name=backrub .../&gt;
&lt;MetropolisHastings ...&gt;
  &lt;Add mover_name=backrub sampling_weight=(1 &amp;Real)/&gt;
&lt;/MetropolisHastings&gt;</pre>
<p></p></li></ol>
<p></p><p>In either case, the probability that any given submover will be chosen during the simulation can be controlled using the sampling_weight parameter. The sampling weights for all movers are automatically normalized to 1. Submovers used with MetropolisHastings must be subclasses of ThermodynamicMover.
</p><p>In addition to trial movers, you can also specify a specialized mover that will change the temperature or score function during the simulation. This type of mover is called a TemperatureController. Finally, additional movers that only record simulation statistics after each trial move can also be used, which are known as ThermodynamicObserver modules.
</p><p>Both the TemperatureController and ThermodynamicObserver modules can be specified in the same two ways as trial movers, with the sampling_weight excluded, for example:
</p>
<pre style="white-space:pre-wrap">&lt;MetropolisHastings ...&gt;
  &lt;Backrub sampling_weight=(1 &amp;Real) .../&gt;
  &lt;SimulatedTempering temp_low=(0.6 &amp;Real) .../&gt;
  &lt;PDBTrajectoryRecorder stride=(100 &amp;Size) filename=(traj.pdb &amp;string)/&gt;
  &lt;MetricRecorder stride=(100 &amp;Size) filename=(metrics.txt &amp;string)&gt;
    &lt;Torsion rsd=(&amp;string) type=(&amp;string) torsion=(&amp;Size) name=("" &amp;string)/&gt;
  &lt;/MetricRecorder&gt;
&lt;/MetropolisHastings&gt;</pre>
<a name="IteratedConvergence"></a><h4>IteratedConvergence</h4>
<p>Repeatedly applies a sub-mover until the given filter returns a value within the given delta for the given number of cycles
</p><p>&lt;IteratedConvergence name=(&amp;string) mover=(&amp;string) filter=(&amp;string) delta=(0.1 &amp;real) cycles=(1 &amp;integer) maxcycles=(1000 &amp;integer) /&gt;
</p>
<ul><li> mover - the mover to repeatedly apply
</li><li> filter - the filter to use when assaying for convergence (should return a reasonable value from report_sm())
</li><li> delta - how close do the filter values have to be to count as converged
</li><li> cycles - for how many mover applications does the filter value have to fall within <tt>delta</tt> of the reference value before counting as converged. If the filter is outside of the range, the reference value is reset to the new filter value.
</li><li> maxcycles - exit regardless if filter doesn't converge within this many applications of the mover - intended mainly as a safety check to prevent infinite recursion.
</li></ul>
<a name="RampMover"></a><h4>RampMover</h4>
<p>Repeatedly applies a given mover while ramping the score from a low value to a high value.  
</p>
<pre style="white-space:pre-wrap">&lt;RampingMover name=(&amp;string) start_weight=(&amp;real) end_weight=(&amp;real) outer_cycles=(&amp;real) inner_cycles=(&amp;real) score_type=(&amp;string) ramp_func=(&amp;string) montecarlo=(&amp;string) mover=(&amp;string)/&gt;</pre>
<ul>
<li> start_weight - starting weight for ramp
</li><li> end_weight - ending weight for ramp
</li><li> outer_cycles - number of increments to ramp score in
</li><li> inner_cycles - number of times to call inner mover in each score ramp increment
</li><li> score_type - name of the score term to ramp
</li><li> ramp func - the ramp funct to use, valid options are linear, geometric, or inverse_geometric
</li><li> montecarlo - the name of the montecarlo object to use
</li><li> mover - name of the inner mover to use.
</li></ul>
<a name="Reporting.2FSaving"></a><h3>Reporting/Saving</h3>
<a name="ReportToDB"></a><h4>ReportToDB</h4>
<p>This mover reports specified features of each input pose to a relational database.  Depending upon which features are used, this can be an effective way of extracting structural information for later analysis.
</p>
<ul>
<li><strong>ReportToDB</strong>:
<ul>
  Required parameters:
  <li><strong>name</strong> <em>(&amp;string)</em>: This is the name of the mover to be used in the PROTOCOLS section.
  </li><li><strong>db</strong> <em>(&amp;string)</em>: The database file name where the feature information is extracted.
  </li><li><strong>sample_source</strong> <em>(&amp;string)</em>: A textual description of the feature database.  Extract with "SELECT description FROM sample_source;"<br><br>
  Optional parameters:
  </li><li><strong>protocol_id</strong> <em>(1 &amp;integer)</em>: Specify the protocol identifier to be used in the <em>protocols</em> table.
  </li><li><strong>struct_id_type</strong> <em>(pose_hash &amp;string)</em>: How the structures should be identified within the database.
  <ul>
    <li><em>pose_hash</em>: Create a string representation of the conformation using the BinaryProteinSilentStruct and then create a 64bit hash of the from the string.
    </li><li><em>auto_increment</em>: Allow the database to auto increment the the <em>struct_id</em> key.
    </li><li><em>manual_increment</em>: Starting from <em>first_struct_id</em>, increment the <em>struct_id</em>. In MPI compatible mode, increment so that the <em>struct_id</em> on node <em>i</em> is congruent to <em>i</em>.
  </li></ul> 
  </li><li><strong>first_struct_id</strong> <em>(1 &amp;integer)</em>: Manually specify the <em>struct_id</em> for the first structure. Note: This requires specifying <em>struct_id_type</em> to be <em>manual_increment</em>.

  </li><li><strong>use_transactions</strong> <em>(1 &amp;bool)</em>: Group together writing to the database in to transactions.
  </li><li><strong>task_operations</strong> <em>("" &amp;string-list)</em>: Apply task operations defined in the &lt;TASKOPERATIONS/&gt; block to determine which residues to extract features.  All residues that are "packable" will be extracted. For features that involve multiple residues, all residues must be packable for the feature to be extracted.
</li></ul>
</li></ul>
<ul><li><strong>feature</strong>: A feature is a <a href="https://svn.rosettacommons.org/trac/browser/trunk/rosetta/rosetta_source/src/protocols/features/FeaturesReporter.hh" class="external" title="https://svn.rosettacommons.org/trac/browser/trunk/rosetta/rosetta source/src/protocols/features/FeaturesReporter.hh">FeatureReporter</a><span class="urlexpansion"> (<i>https://svn.rosettacommons.org/trac/browser/trunk/rosetta/rosetta_source/src/protocols/features/FeaturesReporter.hh</i>)</span> that has been registered with the <a href="https://svn.rosettacommons.org/trac/browser/trunk/rosetta/rosetta_source/src/protocols/features/FeaturesReporterFactory.hh" class="external" title="https://svn.rosettacommons.org/trac/browser/trunk/rosetta/rosetta source/src/protocols/features/FeaturesReporterFactory.hh">FeatureReporterFactory</a><span class="urlexpansion"> (<i>https://svn.rosettacommons.org/trac/browser/trunk/rosetta/rosetta_source/src/protocols/features/FeaturesReporterFactory.hh</i>)</span>.  See the <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/FeaturesScientificBenchmark" title="FeaturesScientificBenchmark">FeaturesScientificBenchmark</a> for how the ReportToDB can be used, especially the page <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/FeaturesDatabaseSchema" title="FeaturesDatabaseSchema">FeaturesDatabaseSchema</a> for details on which features are available.
<ul><li><strong>name</strong> <em>(&amp;string)</em>: This is the name of the feature, e.g. <em>RotamerRecoveryFeatures</em>, that is looked up in the FeatureReporterFactory.
</li><li><strong>scorefxn</strong> <em>(&amp;string): Some features can optionally take a score function when they are initialized.  See <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/FeaturesDatabaseSchema" title="FeaturesDatabaseSchema">FeaturesDatabaseSchema</a> for details.</em>
</li></ul>
</li></ul>
<ul><li><strong>Note</strong>: All feature database come automatically with the following tables:
<ul><li>sample_source: This contains the single column <em>description</em> containing what as in the <em>sample_source</em> tag.
</li><li><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/FeaturesDatabaseSchema#ProtocolFeatures" class="external" title="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/FeaturesDatabaseSchema#ProtocolFeatures">protocols</a><span class="urlexpansion"> (<i>http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/FeaturesDatabaseSchema#ProtocolFeatures</i>)</span>: Information about how Rosetta was invoked.
</li><li><a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/FeaturesDatabaseSchema#StructureFeatures" class="external" title="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/FeaturesDatabaseSchema#StructureFeatures">structures</a><span class="urlexpansion"> (<i>http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/FeaturesDatabaseSchema#StructureFeatures</i>)</span>: Identifiers for each structure contained in the feature database.
</li></ul>
</li></ul>
<pre style="white-space:pre-wrap">&lt;ReportToDB name="&amp;string" db="&amp;string" sample_source="&amp;string"&gt;
   &lt;feature name="&amp;string" scorefxn=(&amp;string)/&gt;
   &lt;feature name="&amp;string" scorefxn=(&amp;string)/&gt;
   .
   .
   .
&lt;/ReportToDB&gt;
</pre>
<p>You may find this short <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/FeaturesTutorialSQLBasics" title="FeaturesTutorialSQLBasics">tutorial</a> on how to do SQL queries on a database once you have generated it.
</p><p>See the <a href="https://svn.rosettacommons.org/trac/browser/trunk/rosetta/rosetta_tests/integration/tests/features" class="external" title="https://svn.rosettacommons.org/trac/browser/trunk/rosetta/rosetta tests/integration/tests/features">features</a><span class="urlexpansion"> (<i>https://svn.rosettacommons.org/trac/browser/trunk/rosetta/rosetta_tests/integration/tests/features</i>)</span> integration test (rosetta/rosetta_tests/integration/tests/features) for a full working example, and the <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/FeaturesScientificBenchmark" title="FeaturesScientificBenchmark">features scientific benchmark</a> for a more extensive usage.
</p>
<a name="DumpPdb"></a><h4>DumpPdb</h4>
<p>Dumps a pdb. Recommended ONLY for debuggging as you can't change the name of the file during a run. If scorefxn is specified, a scored pdb will be dumped.
</p>
<pre>&lt;DumpPdb name=(&amp;string) fname=(dump.pdb &amp;string) scorefxn=(&amp;string)/&gt;</pre>
<a name="PDBTrajectoryRecorder"></a><h4>PDBTrajectoryRecorder</h4>
<p>Record a trajectory to a multimodel PDB file. Only record models every n times using stride. Append ".gz" to filename to use compression.
</p>
<pre style="white-space:pre-wrap">&lt;PDBTrajectoryRecorder stride=(100 &amp;Size) filename=(traj.pdb &amp;string) cumulate_jobs=(0 &amp;bool) cumulate_replicas=(0 &amp;bool)/&gt;</pre>
<p>If run with MPI, the cumulate_jobs and cumulate_replicas parameters affect the filename where the trajectory is ultimately written. For instance, with the default filename parameter of <tt>traj.pdb</tt>, input structure name of <tt>structname</tt>, trajectory number of <tt>XXXX</tt>, and replica number of <tt>YYY</tt>, the following names will be generated given the options.
</p>
<ul><li> cumulate_jobs=0 cumulate_replicas=0: structname_XXXX_YYY_traj.pdb
</li><li> cumulate_jobs=0 cumulate_replicas=1: structname_XXXX_traj.pdb
</li><li> cumulate_jobs=1 cumulate_replicas=0: YYY_traj.pdb
</li><li> cumulate_jobs=1 cumulate_replicas=1: traj.pdb
</li></ul>
<a name="SilentTrajectoryRecorder"></a><h4>SilentTrajectoryRecorder</h4>
<p>Record a trajectory of snapshots as silent-file.
</p>
<pre style="white-space:pre-wrap">&lt;SilentTrajectoryRecorder stride=(100 &amp;Size) score_stride=(100 &amp;Size) filename=(traj &amp;string) cumulate_jobs=(0 &amp;bool) cumulate_replicas=(0 &amp;bool)/&gt;</pre>
<p>By default, this will actually generate PDB file output. To get silent file output, several additional command line flags are required:
</p>
<pre>  -out:file:silent &lt;silent filename&gt; -run:intermediate_structures
</pre>
<p>If used within <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#MetropolisHastings" title="">MetropolisHastings</a>, the current job output name becomes part of the filename. If run with MPI, the cumulate_jobs and cumulate_replicas parameters affect the filename where the trajectory is ultimately written. For instance, with the default filename parameter of <tt>traj</tt>, input structure name of <tt>structname</tt>, trajectory number of <tt>XXXX</tt>, replica number of <tt>YYY</tt>, and <tt>-out:file:silent default.out</tt>, the following names will be generated given the options.
</p>
<ul><li> cumulate_jobs=0 cumulate_replicas=0: default_structname_XXXX_YYY_traj.out
</li><li> cumulate_jobs=0 cumulate_replicas=1: default_structname_XXXX_traj.out
</li><li> cumulate_jobs=1 cumulate_replicas=0: default_YYY_traj.out
</li><li> cumulate_jobs=1 cumulate_replicas=1: default_traj.out
</li></ul>
<a name="MetricRecorder"></a><h4>MetricRecorder</h4>
<p>Record numeric metrics to a tab-delimited text file. Only record metrics every n times using stride. Append ".gz" to filename to use compression. 
</p><p>Currently only torsion angles can be recorded, specified using the TorsionID. The residue can be indicated using absolute Rosetta number (integer) or with the PDB number and chain (integer followed by character).
</p>
<pre style="white-space:pre-wrap">&lt;MetricRecorder stride=(100 &amp;Size) filename=(metrics.txt &amp;string) cumulate_jobs=(0 &amp;bool) cumulate_replicas=(0 &amp;bool) prepend_output_name=(0 &amp;bool) &gt;
  &lt;Torsion rsd=(&amp;string) type=(&amp;string) torsion=(&amp;Size) name=("" &amp;string)/&gt;
  ...
&lt;/MetricRecorder&gt;</pre>
<p>If used within <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#MetropolisHastings" title="">MetropolisHastings</a>, the current job output name is prepended to filename. If run with MPI, the cumulate_jobs and cumulate_replicas parameters affect the filename where the metrics are ultimately written. For instance, with the default filename parameter of <tt>metrics.txt</tt>, input structure name of <tt>structname</tt>, trajectory number of <tt>XXXX</tt>, and replica number of <tt>YYY</tt>, the following names will be generated given the options.
</p>
<ul><li> cumulate_jobs=0 cumulate_replicas=0: structname_XXXX_YYY_metrics.txt
</li><li> cumulate_jobs=0 cumulate_replicas=1: structname_XXXX_metrics.txt
</li><li> cumulate_jobs=1 cumulate_replicas=0: YYY_metrics.txt
</li><li> cumulate_jobs=1 cumulate_replicas=1: metrics.txt
</li></ul>
<p>If not used within MetropolisHastings, by default the current job output name will not be prepended to the filename, similar to <tt>metrics.txt</tt> above. If <tt>prepend_output_name=1</tt>, then it will be prepended following the format, <tt>structname_XXXX_metrics.txt</tt>.
</p>
<a name="General_Movers"></a><h2>General Movers</h2>
<p>These movers are general and should work in most cases. They are usually not aware of things like interfaces, so may be most appropriate for monomers or basic tasks.
</p>
<a name="Packing.2FMinimization"></a><h3>Packing/Minimization</h3>
<a name="PackRotamersMover"></a><h4>PackRotamersMover</h4>
<p>Repacks sidechains with user-supplied options, including TaskOperations
</p>
<pre style="white-space:pre-wrap">&lt;PackRotamersMover name="&amp;string" scorefxn=(score12 &amp;string) task_operations=(&amp;string,&amp;string,&amp;string)/&gt;</pre>
<ul>
<li>scorefxn: scorefunction to use for repacking
</li><li>taskoperations: comma-separated list of task operations. These must have been previously defined in the TaskOperations section.
</li></ul>
<a name="MinMover"></a><h4>MinMover</h4>
<p>Does minimization over sidechain and/or backbone
</p>
<pre style="white-space:pre-wrap">&lt;MinMover name="&amp;string" scorefxn=(score12 &amp;string) chi=(&amp;bool) bb=(&amp;bool) jump=(&amp;string) type=(dfpmin_armijo_nonmonotone &amp;string) tolerance=(0.01&amp;Real)&gt;
  &lt;MoveMap&gt;
    ...
  &lt;/MoveMap&gt;
&lt;/MinMover&gt;

</pre>
<p>Note that defaults are as for the MinMover class! Check MinMover.cc for the default constructor.
</p>
<ul>
<li>MinMover is also sensitive to a MoveMap block, just like FastRelax.
</li><li>scorefxn: scorefunction to use during minimization
</li><li>chi: minimize sidechains?
</li><li>bb: minimize backbone?
</li><li>jump: comma-separated list of jumps to minimize over (be sure this jump exists!)
</li><li>type: minimizer type. linmin, dfpmin, dfpmin_armijo, dfpmin_armijo_nomonotone. dfpmin minimzers can also be used with absolute tolerance (add "atol" to the minimizer type). See <a href="https://www.rosettacommons.org/internal/doc/mini/all_else/minimization_overview.html" class="external" title="https://www.rosettacommons.org/internal/doc/mini/all_else/minimization_overview.html">https://www.rosettacommons.org/internal/doc/mini/all_else/minimization_overview.html</a> for details. 
</li><li>tolerance: criteria for convergence of minimization. <b>The default is very loose, it's recommended to specify something less than 0.01.</b>
</li><li>MoveMap: The movemap can be programmed down to individual degrees of freedom. See FastRelax for more details.
</li></ul>
<a name="TaskAwareMinMover"></a><h4>TaskAwareMinMover</h4>
<p>Performs minimization. Accepts TaskOperations via the task_operations option e.g.
</p>
<pre>task_operations=(&amp;string,&amp;string,&amp;string)</pre>
<p>to configure which positions are minimized. Options
</p>
<pre>chi=(&amp;bool) and bb=(&amp;bool)</pre> control sidechain or backbone freedom. Defaults to sidechain minimization. Options scorefxn, jump, type, and tolerance are passed to the underlying MinMover
<a name="MinPackMover"></a><h4>MinPackMover</h4>
<p>Packs then minimizes a sidechain before calling MonteCarlo on the change. It can be modified with user supplied ScoreFunction or TaskOperation. It does not do backbone, ridged body minimization. 
</p>
<pre style="white-space:pre-wrap">&lt;MinPackMover name="&amp;string" scorefxn=("score12" &amp;string) task_operations=(&amp;string,&amp;string,&amp;string)/&gt;</pre>
<p>It is reccomended to change the weights you are using to the <strong>score12minpack</strong> weights. These are the standard score12 weights with the reference energies refit for sequence recovery profile when using the MinPackMover. Without these weights you will see a lot of Tryptophan residues on the surface of a protein.
</p>
<ul><li> Tags:
</li><li> <strong>scorefxn</strong>: scorefunction to use for packing and minimization, default is score12. It is reccomended to change this to <strong>score12minpack</strong>.
</li><li> <strong>task_operations</strong>: comma-separated list of task operations. These must have been previously defined in the TaskOperations section. Default is to design all residues.
</li><li> What is the input FoldTree, what is the output FoldTree.
<ul><li> The mover itself is not FoldTree sensitive, however the TaskOperations might be. This mover does not modify the fold tree.
</li><li>Does it take and output a default FoldTree or does it need/output a modified fold tree.
</li></ul>
</li><li> Does it take a pose with a certain chemical or topological property? 
<ul><li> Does not require a special type of Pose.
</li></ul>
</li><li> Does it change the length of the Pose?
<ul><li> No.
</li></ul>
</li><li> Does it change the ConstraintSet?
<ul><li> No.
</li></ul>
</li><li> When given some particular piece of data (mover? fragment set? scorefunction), does it keep a copy of it or a pointer to it?
<ul><li> It does not modify the ScoreFunction.
</li></ul>
</li></ul>
<a name="Sidechain"></a><h4>Sidechain</h4>
<p>The "off rotamer" sidechain-only moves.
</p>
<pre style="white-space:pre-wrap">&lt;Sidechain name=(&amp;string) preserve_detailed_balance=(1 &amp;bool) task_operations=(&amp;string,&amp;string,&amp;string) prob_uniform=(0.0 &amp;real) prob_withinrot=(0.0 &amp;real) prob_random_pert_current=(0.0 &amp;real)/&gt;</pre>
<ul>
<li>preserve_detailed_balance: balance acceptance criterion with proposal density ratio</li>
<li>task_operations: list of operations for generating a PackerTask</li>
<li>prob_uniform: probability of a "uniform" move - all sidechain chis are uniformly randomized between -180 and 180</li>
<li>prob_withinrot: "within rotamer" - sidechain chis are picked from the Dunbrack distribution for the current rotamer</li>
<li>prob_random_pert_current: "random perturbation of current position" - the current sidechain chis are perturbed 10 from their current positions, biased by the resulting Dunbrack energy. Note that if your score function contains a Dunbrack energy term, this will result in double counting issues.</li>
<li>If the previous three probabilities do not add to 1.0, the remainder is assigned to a "between rotamer" move - a random rotamer of the current amino acid is chosen, and chi angles for that rotamer are selected from the Dunbrack distribution</li>
</ul>
<a name="SidechainMC"></a><h4>SidechainMC</h4>
<p>The "off rotamer" sidechain-only Monte Carlo sampler. For a rather large setup cost, individual moves can be made efficiently.
</p><p>The underlying mover is still under development/benchmarking, so it may or may not work with backbone flexibility or amino acid identity changes.
</p>
<pre style="white-space:pre-wrap">&lt;SidechainMC name=(&amp;string) ntrials=(10000 &amp;int) scorefxn=(score12 &amp;string) temperature=(1.0 &amp;real) inherit_scorefxn_temperature=(0 &amp;bool) preserve_detailed_balance=(1 &amp;bool) task_operations=(&amp;string,&amp;string,&amp;string) prob_uniform=(0.0 &amp;real) prob_withinrot=(0.0 &amp;real) prob_random_pert_current=(0.0 &amp;real)/&gt;</pre>
<ul>
<li>ntrials: number of Monte Carlo trials to make per mover application - should be at least several thousand</li>
<li>scorefxn: score function used for acceptance</li>
<li>temperature: Boltzmann acceptance temperature - usually around 1.0</li>
<li>inherit_scorefxn_temperature: override scorefxn and temperature with values from <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#MetropolisHastings" title="">MetropolisHastings</a></li>
<li>preserve_detailed_balance: balance acceptance criterion with proposal density ratio</li>
<li>task_operations: list of operations for generating a PackerTask</li>
<li>prob_uniform: probability of a "uniform" move - all sidechain chis are uniformly randomized between -180 and 180</li>
<li>prob_withinrot: "within rotamer" - sidechain chis are picked from the Dunbrack distribution for the current rotamer</li>
<li>prob_random_pert_current: "random perturbation of current position" - the current sidechain chis are perturbed 10 from their current positions, biased by the resulting Dunbrack energy. Note that if your score function contains a Dunbrack energy term, this will result in double counting issues.</li>
<li>- If the previous three probabilities do not add to 1.0, the remainder is assigned to a "between rotamer" move - a random rotamer of the current amino acid is chosen, and chi angles for that rotamer are selected from the Dunbrack distribution</li>
</ul>
<a name="RotamerTrialsMover"></a><h4>RotamerTrialsMover</h4>
<p>This mover goes through each repackable/redesignable position in the pose, taking every permitted rotamer in turn, and evaluating the energy. Each position is then updated to the lowest energy rotamer. It does not consider coordinated changes at multiple residues, and may need several invocations to reach convergence.
</p><p>In addition to the score function, the mover takes a list of task operations to specify which residues to consider. (See <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/TaskOperations_%28RosettaScripts%29" title="TaskOperations (RosettaScripts)">TaskOperations (RosettaScripts)</a>.)
</p>
<pre style="white-space:pre-wrap">&lt;RotamerTrialsMover name="&amp;string" scorefxn=(&amp;string) task_operations=(&amp;string,&amp;string,&amp;string) show_packer_task=(0 &amp;bool) /&gt;</pre>
<a name="RotamerTrialsMinMover"></a><h4>RotamerTrialsMinMover</h4>
<p>This mover goes through each repackable/redesignable position in the pose, taking every permitted rotamer in turn, minimizing it in the context of the current pose, and evaluating the energy. Each position is then updated to the lowest energy minimized rotamer. It does not consider coordinated changes at multiple residues, and may need several invocations to reach convergence.
</p><p>In addition to the score function, the mover takes a list of task operations to specify which residues to consider. (See <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/TaskOperations_%28RosettaScripts%29" title="TaskOperations (RosettaScripts)">TaskOperations (RosettaScripts)</a>.)
</p>
<pre style="white-space:pre-wrap">&lt;RotamerTrialsMinMover name="&amp;string" scorefxn=(&amp;string) task_operations=(&amp;string,&amp;string,&amp;string)/&gt;</pre>
<a name="ConsensusDesignMover"></a><h4>ConsensusDesignMover</h4>
<p>This mover will mutate residues to the most-frequently occuring residues in a multiple sequence alignment, while making sure that the new residue scores well in rosetta. 
It takes a position specific scoring matrix (pssm) as input to determine the most frequently occuring residues at each position. The user defines a packer task of the residues which will be designed. At each of these positions only residues which appear as often or more often (same pssm score or higher) will be allowed in subsequent design. Design is then carried out with the desired score function, optionally adding a residues identity constraint proportional to the pssm score (more frequent residues get a better energy). 
</p>
<pre style="white-space:pre-wrap">&lt;ConsensusDesignMover name="&amp;string" scorefxn=(&amp;string) invert_task=(&amp;bool) sasa_cutoff=(&amp;float) use_seqprof_constraints=(&amp;bool) task_operations=(&amp;string)/&gt;</pre>
<ul>
<li>scorefxn: Set the desired score function (defined in a the &lt;SCOREFXNS&gt; block)
</li><li>taskoperations: Hand in a task operation defining the residues you want to design (or their inverse). Without a task_operation and with invert_task=0 everything will be designed.
</li><li>use_seqprof_constraints: Only residues which appear more often in the pssm than the wild-type residue at position i are allowed in the packer task as position i. If use_seqprof_constraints = 0 all of those are allowed with equal probability -- that is, no extra constraint energy is added. If use_seqprof_constraints = 1 the more frequent residues are added to the packer task at residue i and each is granted a sequence constraint roughly proportional to the pssm score. In effect the more-frequent residues are included in proportion to their frequency of occurence in the pssm.
</li><li>sasa_cutoff: Buried residues (with sasa &lt; sasa_cutoff) will not be designed. Surface residues (with sasa &gt; sasa_cutoff) will be designed. To carry out consensus design on all residues in the task simply don't enter a sasa_cutoff or set it to 0.
</li><li>invert_task: A common usage case is to take an interface/ligand packer task and then do consensus design for everything outside of that design (which is presumably optimized by rosetta for binding). That use requires a task that is the opposite of the original task. This flag turns on that inverted task. 
</li></ul>
<a name="Idealize.2FRelax"></a><h3>Idealize/Relax</h3>
<a name="Idealize"></a><h4>Idealize</h4>
<p>Some protocols (LoopHashing) require the pose to have ideal bond lengths and angles. Idealize forces these values and then minimizes the pose in a stripped-down energy function (rama, disulf, and proline closure) and in the presence of coordinate constraints. Typically causes movements of 0.1A from original pose, but the scores deteriorate. It is therefore recommended to follow idealization with some refinement.
</p>
<pre style="white-space:pre-wrap">&lt;Idealize name=(&amp;string) atom_pair_constraint_weight=(0.0&amp;Real) coordinate_constraint_weight=(0.01&amp;Real) fast=(0 &amp;bool) report_CA_rmsd=(1 &amp;bool) ignore_residues_in_csts=(&amp;comma delimited residue list) impose_constraints=(1&amp;bool) constraints_only=(0&amp;bool)/&gt;</pre>
<ul>
<li> ignore_residues_in_csts: set certain residues to not have coordinate constraints applied to them during idealization, meaning that they're free to move in order to form completely ideal bonds. Useful when, e.g., changing loop length and quickly making a chemically sensible chain.
</li><li> impose_constraints: impose the coordinate and pair constraints on the current pose?
</li><li> constraints_only: jump out of idealize after imposing the constraints without doing the actual idealization run?
</li></ul>
<p>impose_constraints &amp; constraints_only can be used intermittently to break the idealize process into two stages: first impose the constraints on a 'realistic' pose without idealizing (constraints_only=1), then mangle the pose and apply idealize again (impose_constraints=0).
</p>
<a name="FastRelax"></a><h4>FastRelax</h4>
<p>Performs the fast relax protocol.
</p>
<pre>&lt;FastRelax name="&amp;string" scorefxn=(score12 &amp;string) repeats=(8 &amp;int) task_operations=(&amp;string, &amp;string, &amp;string &gt;
   &lt;MoveMap name=(""&amp;string)&gt;
      &lt;Chain number=(&amp;integer) chi=(&amp;bool) bb=(&amp;bool)/&gt;
      &lt;Jump number=(&amp;integer) setting=(&amp;bool)/&gt;
      &lt;Span begin=(&amp;integer) end=(&amp;integer) chi=(&amp;bool) bb=(&amp;bool)/&gt;
   &lt;/MoveMap&gt;
</pre>
<p>Options include:
</p>
<ul>
<li>scorefxn  (default "score12") 
</li><li>repeats  (default 8)
</li><li>task_operations ( default implicitly defined as InitializeFromCommandline, IncludeCurrent, and RestrictToRepacking  )
</li><li> MoveMap name: this is optional and would actually not work with all movers, including FastRelax. The name allows the user to specify a movemap that can later be called by another mover without specifying all of the options. Movers that do not support this functionality will exit with an error message.
</li></ul>
<p>The MoveMap is initially set to minimize all degrees of freedom. The movemap lines are read in the order in which they are written in the xml file, and can be used to turn on or off dofs. The movemap is parsed only at apply time, so that the foldtree and the kinematic structure of the pose at the time of activation will be respected.
</p>
<a name="Docking.2FAssembly"></a><h3>Docking/Assembly</h3>
<a name="DockingProtocol"></a><h4>DockingProtocol</h4>
<p>Runs the full (post refactoring) docking protocol with the defaults currently in trunk.  This mover is not currently sensitive to symmetry.
</p>
<pre style="white-space:pre-wrap">&lt;DockingProtocol name="&amp;string" docking_score_low=(interchain_cen &amp;string) docking_score_high=(docking &amp;string) low_res_protocol_only=(0 &amp;bool) docking_local_refine(0 &amp;bool) dock_min=(0 &amp;bool) ignore_default_docking_task=(0 &amp;bool) task_operations=("" comma-separated list) partners=(&amp;string)&gt;</pre>
<ul>
<li> docking_score_low: score function used in centroid mode of the docking steps
</li><li> docking_score_high: score function used in full atom mode of docking
</li><li> low_res_protocol_only: if true, only do centroid level docking
</li><li> docking_local_refine: if true skip the centroid level and only do full atom docking 
</li><li> dock_min: if true minimize the final full atom structure
</li><li> partners: allows fold tree modifications to dock across multiple chains (example: docking chains L+H with A is partners="LH_A")
</li><li> ignore_default_docking_task: allows you to ignore the default DockingTaskFactory set by docking and give it your own definition of an interface. Not suggested.
</li><li> task_operations: comma separated list of TaskOperations, these will be appended onto that defined by DockingTaskFactory, unless ignore_default_docking_task is turned on.
</li><li>partners: _ separated list of chains to dock.
</li></ul>
<a name="FlexPepDock"></a><h4>FlexPepDock</h4>
<p>Flexible peptide docking protocol. This tag encompasses 2 closely related protocols:
</p>
<ul>
<li>The <strong>Refinement protocol</strong> is intended for cases where an approximate, coarse-grain model of the interaction is available, as described in Raveh, London et al., Proteins 2010. The protocol iteratively optimizes the peptide backbone and its rigid-body orientation relative to the receptor protein, in addition to on-the-fly side-chain optimization. The pep_refine option invokes the refinement protocol.

</li><li>The <strong>ab-initio protocol</strong> extends the refinement protocol considerably, and is intended for cases where no information is available about the peptide backbone conformation, as described in Raveh et al., PLoS ONE Rosetta Special Collection, 2011. FlexPepDock ab-initio simultaneously folds and docks the peptide over the receptor surface, starting from any arbitrary (e.g., extended) backbone conformation. It is assumed that the peptide is initially positioned close to the correct binding site, but the protocol is robust to the exact starting orientation. The protocol is invoked by the lowres_abinitio option, usually in combination with the pep_refine option, for refinement of the resulting coarse model. It is recommended to also supply the protocol with fragment files of 3-mers, 5-mers (and 9-mers for peptides of length 9 or more).
</li></ul>
<p><strong>Basic options:</strong><br>
</p>
<ul>
<li>min_only (boolean) - Apply just a minimization step
</li><li>pep_refine (boolean) - Invoke the refinement protocol
</li><li>lowres_abinitio (boolean) - Invoke the ab-initio protocol
</li><li>peptide_chain (string) - Manually specify the peptide chain (default is the 2nd chain)
</li><li>receptor_chain (string) - Manually specify the receptor (protein) chain. (default is the 1st chain)
</li><li>ppk_only (boolean) - Just prepacking
</li><li>scorefxn (string) - the score function to use
</li><li>extra_scoring (boolean) - scoring only mode
</li></ul>
<p>Note that only one of the 5 can exist in a tag: extra_scoring,ppk_only,pep_refine,lowres_abinitio,min_only.
</p>
<pre>&lt;FlexPepDock name=(&amp;string) min_only=(&amp;boolean) pep_refine=(&amp;boolean)
 lowres_abinitio=(&amp;boolean) peptide_chain=(&amp;string) receptor_chain=(&amp;string) 
ppk_only=(&amp;boolean) scorefxn=(&amp;string) extra_scoring=(&amp;boolean)/&gt;</pre>
<a name="Backbone_Movement"></a><h3>Backbone Movement</h3>
<a name="SetTorsion"></a><h4>SetTorsion</h4>
<p>Sets a given torsion to a specified value.
</p>
<pre style="white-space:pre-wrap">&lt;SetTorsion name="&amp;string" resnum=(pdb/rosetta numbering) torsion_name=(&amp;string) angle=(&amp;real)/&gt;</pre>
<ul>
<li> resnum: which residue? either rosetta numbering or pdb (25A)
</li><li> torsion_name: phi/psi.
</li></ul>
<a name="Shear"></a><h4>Shear</h4>
<p>Shear style backbone-torsion moves that minimize downstream propagation.
</p>
<pre style="white-space:pre-wrap">&lt;Shear name="&amp;string" temperature=(0.5 &amp;Real) nmoves=(1 &amp;Integer) angle_max=(6.0 &amp;Real) preserve_detailed_balance=(0 &amp;bool)/&gt;</pre>
<ul>
<li> temperature: what MC acceptance temperature to use (tests only the rama score, so not a full MC).
</li><li> nmoves: how many consecutive moves to make.
</li><li> angle_max: by how much to perturb the backbone.
</li><li> preserve_detailed_balance: If set to true, does not test the MC acceptance criterion, and instead always accepts.
</li></ul>
<p>See Rohl CA, et al. (2004) Methods Enzymol. Protein structure prediction using Rosetta, 383:66
</p>
<a name="Small"></a><h4>Small</h4>
<p>Small-move style backbone-torsion moves that, unlike shear, do not minimize downstream propagation.
</p>
<pre style="white-space:pre-wrap">&lt;Shear name="&amp;string" temperature=(0.5 &amp;Real) nmoves=(1 &amp;Integer) angle_max=(6.0 &amp;Real) preserve_detailed_balance=(0 &amp;bool)/&gt;</pre>
<ul>
<li> temperature: what MC acceptance temperature to use (tests only the rama score, so not a full MC).
</li><li> nmoves: how many consecutive moves to make.
</li><li> angle_max: by how much to perturb the backbone.
</li><li> preserve_detailed_balance: If set to true, does not test the MC acceptance criterion, and instead always accepts.
</li></ul>
<p>See Rohl CA, et al. (2004) Methods Enzymol. Protein structure prediction using Rosetta, 383:66
</p>
<a name="Backrub"></a><h4>Backrub</h4>
<p>Purely local moves using rotations around axes defined by two backbone atoms.
</p>
<pre style="white-space:pre-wrap">&lt;Backrub name=(&amp;string) pivot_residues=(all residues &amp;string) pivot_atoms=(CA &amp;string) min_atoms=(3 &amp;Size) max_atoms=(34 &amp;Size) max_angle_disp_4=(40/180*pi &amp;Real) max_angle_disp_7=(20/180*pi &amp;Real) max_angle_disp_slope=(-1/3/180*pi &amp;Real) preserve_detailed_balance=(0 &amp;bool) require_mm_bend=(1 &amp;bool)/&gt;</pre>
<ul>
<li> pivot_residues: residues for which contiguous stretches can contain segments (comma separated) can use PDB numbers (&lt;resnum&gt;&lt;chain&gt;) or absolute Rosetta numbers (integer)
</li><li> pivot_atoms: main chain atoms usable as pivots (comma separated)
</li><li> min_atoms: minimum backrub segment size (atoms)
</li><li> max_atoms: maximum backrub segment size (atoms)
</li><li> max_angle_disp_4: maximum angular displacement for 4 atom segments (radians)
</li><li> max_angle_disp_7: maximum angular displacement for 7 atom segments (radians)
</li><li> max_angle_disp_slope: maximum angular displacement slope for other atom segments (radians)
</li><li> preserve_detailed_balance: if set to true, does not change branching atom angles during apply and sets ideal branch angles during initialization if used with MetropolisHastings
</li><li> require_mm_bend: if true and used with MetropolisHastings, will exit if mm_bend is not in the score function
</li></ul>
<a name="Constraints"></a><h3>Constraints</h3>
<a name="ConstraintSetMover"></a><h4>ConstraintSetMover</h4>
<p>Adds constraints to the pose using the constraints' read-from-file functionality.
</p>
<pre style="white-space:pre-wrap">&lt;ConstraintSetMover name=(&amp;string) cst_file=(&amp;string)/&gt;</pre>
<p>cst_file: the file containing the constraint data. e.g.,:
</p>
<pre>...
CoordinateConstraint CA 1 CA 380   27.514  34.934  50.283 HARMONIC 0 1
CoordinateConstraint CA 1 CA 381   24.211  36.849  50.154 HARMONIC 0 1
...</pre>
<a name="TaskAwareCsts"></a><h4>TaskAwareCsts</h4>
<p>Add coordinate constraints to all residues that are considered designable by the task_operations. Mean and SD are hardwired to 0,1 at present. If you want to use this, don't forget to make downstream movers aware of coordinate constraints by changing their scorefxn's coordinate_constraint weight.
</p>
<pre style="white-space:pre-wrap">&lt;TaskAwareCsts name=(&amp;string) task_operations=(&amp;comma-delimited list of task operations)/&gt;</pre>
<a name="Fragment_Insertion"></a><h3>Fragment Insertion</h3>
<a name="SingleFragmentMover"></a><h4>SingleFragmentMover</h4>
<p>Performs a single fragment insertion move on the pose. Respects the restrictions imposed by the user-supplied <em>MoveMap</em> and underlying kinematics of the pose (i.e. <em>FoldTree</em>). By default, all backbone torsions are movable. The <em>MoveMap</em> parameter is used to specify residues that should remain fixed during the simulation. Insertion positions are chosen in a biased manner in order to have roughly equivalent probability of acceptance at each allowable insertion position. This has traditionally been referred to as "end-biasing." Once an insertion position has been chosen, a <em>Policy</em> object is responsible for choosing from among the possible fragments contained in the fragment file. Currently, two policies are supported-- "uniform" and "smooth." The former chooses uniformly amongst the set of possibilities. The latter chooses the fragment that, if applied, causes minimal distortion to the pose.
</p><p>In order to be useful, <em>SingleFragmentMover</em> should be paired with a Monte Carlo-based mover. If you're folding from the extended chain, "GenericMonteCarloMover" is a common choice. When folding from a reasonable starting model, "GenericMonteCarloMover" is *not* recommended-- it unilaterally accepts the first move. A simplified version of the  <em>ClassicAbinitio</em> protocol is recapitulated in demo/rosetta_scripts/classic_abinitio.xml.
</p><p>Input is *not* restricted to monomers. Oligomers work fine.
</p>
<pre style="white-space:pre-wrap">
&lt;SingleFragmentMover name=(&amp;string) fragments=(&amp;string) policy=(uniform &amp;string)&gt;
  &lt;MoveMap&gt;
    &lt;Span begin=(&amp;int) end=(&amp;int) chi=(&amp;int) bb=(&amp;int)/&gt;
  &lt;/MoveMap&gt;
&lt;/SingleFragmentMover&gt;

</pre>
<a name="Symmetry"></a><h3>Symmetry</h3>
<p>The following set of movers are aimed at creating and manipulating symmetric poses within RosettaScripts.  For the complete symmetry documentation, see the "Symmetry User's Guide" in Rosetta's Doxygen documentation.
</p><p>Notice that symmetric poses must be scored with symmetric score functions.  See the 'symmetric' tag in the RosettaScripts score function documentation.
</p>
<a name="SetupForSymmetry"></a><h4>SetupForSymmetry</h4>
<p>Given a symmetry definition file that describes configuration and scoring of a symmetric system, this mover "symmetrizes" an asymmetric pose.  For example, given the symmetry definition file 'C2.symm':
</p>
<pre style="white-space:pre-wrap">&lt;SetupForSymmetry name=setup_symm definition=C2.symm/&gt;
</pre>
<a name="ExtractAsymmetricUnit"></a><h4>ExtractAsymmetricUnit</h4>
<p>The inverse of SetupForSymmetry: given a symmetric pose, make a nonsymmetric pose that contains only the asymmetric unit.
</p>
<pre style="white-space:pre-wrap">&lt;ExtractAsymmetricUnit name=extract_asu/&gt;
</pre>
<a name="ExtractAsymmetricPose"></a><h4>ExtractAsymmetricPose</h4>
<p>Similar to ExtractAsymmetricUnit: given a symmetric pose, make a nonsymmetric pose that contains the entire system (all monomers). Can be used to run symmetric and asymmetric moves in the same trajectory.
</p>
<pre style="white-space:pre-wrap">&lt;ExtractAsymmetricPose name=extract_asp/&gt;
</pre>
<a name="SymPackRotamersMover_and_SymRotamerTrialsMover"></a><h4>SymPackRotamersMover and SymRotamerTrialsMover</h4>
<p>The symmetric versions of pack rotamers and rotamer trials movers (they take the same tags as asymmetric versions)
</p>
<pre style="white-space:pre-wrap">&lt;SymPackRotamersMover name=symm_pack_rot scorefxn=score12_symm task_operations=.../&gt;
&lt;SymRotamerTrialsMover name=symm_rot_trials scorefxn=score12_symm task_operations=.../&gt;
</pre>
<a name="SymMinMover"></a><h4>SymMinMover</h4>
<p>The symmetric version of min mover (they take the same tags as asymmetric version).  Notice that to refine symmetric degrees of freedom, all jumps must be allowed to move with the tag 'jump=ALL'.
</p>
<pre style="white-space:pre-wrap">&lt;SymMinMover name=min1 scorefxn=ramp_rep1 bb=1 chi=1 jump=ALL/&gt;
</pre>
<a name="Example:_Symmetric_FastRelax"></a><h4>Example: Symmetric FastRelax</h4>
<p>The following RosettaScript runs a protocol similar to Rosetta's symmetric fast relax using the symmetric pack rotamers and symmetric min mover (note that the fastrelax mover respects symmetric poses, this example is merely done to illustrate the symmetric movers).
</p>
<pre style="white-space:pre-wrap">&lt;dock_design&gt;
	&lt;TASKOPERATIONS&gt;
		&lt;InitializeFromCommandline name=init/&gt;
		&lt;RestrictToRepacking name=restrict/&gt;
		&lt;IncludeCurrent name=keep_curr/&gt;
	&lt;/TASKOPERATIONS&gt;
	&lt;SCOREFXNS&gt;
		&lt;ramp_rep1 weights=score12_full symmetric=1&gt;
			&lt;Reweight scoretype=fa_rep weight=0.0088/&gt;
		&lt;/ramp_rep1&gt;
		&lt;ramp_rep2 weights=score12_full symmetric=1&gt;
			&lt;Reweight scoretype=fa_rep weight=0.11/&gt;
		&lt;/ramp_rep2&gt;
		&lt;ramp_rep3 weights=score12_full symmetric=1&gt;
			&lt;Reweight scoretype=fa_rep weight=0.22/&gt;
		&lt;/ramp_rep3&gt;
		&lt;ramp_rep4 weights=score12_full symmetric=1/&gt;
	&lt;/SCOREFXNS&gt;
	&lt;FILTERS&gt;
	&lt;/FILTERS&gt;
	&lt;MOVERS&gt;
		&lt;SetupForSymmetry   name=setup_symm definition=C2.symm/&gt;
		&lt;SymPackRotamersMover name=repack1 scorefxn=ramp_rep1 task_operations=init,restrict,keep_curr/&gt;
		&lt;SymPackRotamersMover name=repack2 scorefxn=ramp_rep2 task_operations=init,restrict,keep_curr/&gt;
		&lt;SymPackRotamersMover name=repack3 scorefxn=ramp_rep3 task_operations=init,restrict,keep_curr/&gt;
		&lt;SymPackRotamersMover name=repack4 scorefxn=ramp_rep4 task_operations=init,restrict,keep_curr/&gt;
		&lt;SymMinMover name=min1 scorefxn=ramp_rep1 type=lbfgs_armijo_nonmonotone tolerance=0.01 bb=1 chi=1 jump=ALL/&gt;
		&lt;SymMinMover name=min2 scorefxn=ramp_rep2 type=lbfgs_armijo_nonmonotone tolerance=0.01 bb=1 chi=1 jump=ALL/&gt;
		&lt;SymMinMover name=min3 scorefxn=ramp_rep3 type=lbfgs_armijo_nonmonotone tolerance=0.01 bb=1 chi=1 jump=ALL/&gt;
		&lt;SymMinMover name=min4 scorefxn=ramp_rep4 type=lbfgs_armijo_nonmonotone tolerance=0.00001 bb=1 chi=1 jump=ALL/&gt;
		&lt;ParsedProtocol name=ramp_rep_cycle&gt;
			&lt;Add mover=repack1/&gt;
			&lt;Add mover=min1/&gt;
			&lt;Add mover=repack2/&gt;
			&lt;Add mover=min2/&gt;
			&lt;Add mover=repack3/&gt;
			&lt;Add mover=min3/&gt;
			&lt;Add mover=repack4/&gt;
			&lt;Add mover=min4/&gt;
		&lt;/ParsedProtocol&gt;
		&lt;GenericMonteCarlo name=genericMC mover_name=ramp_rep_cycle scorefxn_name=ramp_rep4 temperature=100.0 trials=4/&gt; 
	&lt;/MOVERS&gt;
	&lt;APPLY_TO_POSE&gt;
	&lt;/APPLY_TO_POSE&gt;
	&lt;PROTOCOLS&gt;
		&lt;Add mover=setup_symm/&gt;
		&lt;Add mover=genericMC/&gt;
	&lt;/PROTOCOLS&gt;
&lt;/dock_design&gt;
</pre>
<a name="Issues_with_Symmetry_and_Rosetta_Scripts"></a><h4>Issues with Symmetry and Rosetta Scripts</h4>
<p>For the most part, simple movers and filters will handle symmetric poses without modification.  More complicated movers may run into some problems.  To adopt a complex mover for symmetry, see the section "How to adopt your protocol to use symmetry" in the "Symmetry User's Guide" in Rosetta's Doxygen documentation.
</p><p>One RosettaScript-specific problem with parsable movers and symmetry has to do with how the scorefunction map is accessed in parse_my_tag.   When getting a scorefunction off the data map, the following code WILL NOT WORK WITH SYMMETRY:
</p>
<pre style="white-space:pre-wrap">scorefxn_ = new ScoreFunction( *data.get&lt; ScoreFunction * &gt;( "scorefxns", sfxn_name ));
</pre>
<p>This ignores whether 'sfxn_name' is symmetric or not.  Instead, use clone to preserve whether or not the scorefunction is symmetric:
</p>
<pre style="white-space:pre-wrap">scorefxn_ = data.get&lt; ScoreFunction * &gt;( "scorefxns", sfxn_name )-&gt;clone();
</pre>
<p>This often is the problem when a mover gives the following error in a symmetric pose:
</p>
<pre style="white-space:pre-wrap">ERROR:&nbsp;!core::pose::symmetry::is_symmetric( pose )
ERROR:: Exit from: src/core/scoring/ScoreFunction.cc line: 547
</pre>
<a name="Other_Pose_Manipulation"></a><h3>Other Pose Manipulation</h3>
<a name="AddChainBreak"></a><h4>AddChainBreak</h4>
<p>Adds a chainbreak at the specified position
</p>
<pre style="white-space:pre-wrap">&lt;AddChainBreak name=(&amp;string) resnum=(&amp;string) change_foldtree=(1 &amp;bool) find_automatically=(0 &amp;bool) distance_cutoff=(2.5&amp;Real)/&gt;</pre>
<ul>
<li> change_foldtree: add a jump at the cut site.
</li><li> find_automatically: find cutpoints automatically according to the distance between subsequent C and N atoms.
</li><li> distance_cutoff: the distance cutoff between subsequent C and N atoms at which to decide that a cutpoint exists.
</li></ul>
<a name="FoldTreeFromLoops"></a><h4>FoldTreeFromLoops</h4>
<p>Wrapper for utility function fold_tree_from_loops. Defines a fold tree based on loop definitions with the fold tree going up to the loop n-term, and the c-term and jumping between. Cutpoints define the kinematics within the loop
</p>
<pre style="white-space:pre-wrap">&lt;FoldTreeFromLoops name=(&amp;string) loops=(&amp;string)/&gt;</pre>
<p>the format for loops is: Start:End:Cut,Start:End:Cut...
</p><p>and either pdb or rosetta numbering are allowed. The start, end and cut points are computed at apply time so would respect loop length changes.
</p>
<a name="LoopLengthChange"></a><h4>LoopLengthChange</h4>
<p>Changes a loop length without closing it.
</p>
<pre style="white-space:pre-wrap">&lt;LoopLengthChange name=(&amp;string) loop_start=(&amp;resnum) loop_end=(&amp;resnum) delta=(&amp;int)/&gt;</pre>
<ul>
<li> loop_start, loop_end: where the loop starts and ends.
</li><li> delta: by how much to change. Negative values mean cutting the loop.
</li></ul>
<a name="MakePolyX"></a><h4>MakePolyX</h4>
<p>Convert pose into poly XXX ( XXX can be any amino acid )
</p>
<pre>&lt;MakePolyX name="&amp;string" aa="&amp;string" keep_pro=(0 &amp;bool)  keep_gly=(1 &amp;bool) keep_disulfide_cys=(0 &amp;bool) /&gt;
</pre>
<p>Options include:
</p>
<ul>
<li> aa ( default "ALA" ) using amino acid type for converting 
</li><li> keep_pro ( default 0 ) Pro is not converted to XXX
</li><li> keep_gly ( default 1 )  Gly is not converted to XXX
</li><li> keep_disulfide_cys ( default 0 ) disulfide CYS is not converted to XXX
</li></ul>
<a name="MembraneTopology"></a><h4>MembraneTopology</h4>
<p>Simple wrapper around the MembraneTopology object in core/scoring. Takes in a membrane span file and inserts the membrane topology into the pose cache. The pose can then be used with a membrane score function.
</p>
<pre style="white-space:pre-wrap">&lt;MembraneTopology name=(&amp;string) span_file=(&amp;string)/&gt;</pre>
<p>Span files have the following structure:
</p>
<ul>
<li> comment line
</li><li> 1 23              number of tm helices, number of residues
</li><li> parallel          topology
</li><li> n2c               n2c or c2n
</li><li> 1 27 1 27         the residue spans in rosetta-internal numbering. For some reason needs to be written twice for each membrane span
</li></ul>

<a name="SwitchResidueTypeSetMover"></a><h4>SwitchResidueTypeSetMover</h4>
<p>Switches the residue sets (e.g., allatom-&gt;centroid, or vice versa).
</p>
<pre style="white-space:pre-wrap">&lt;SwitchResidueTypeSetMover name="&amp;string" set=(&amp;string)/&gt;</pre>
<ul>
<li> set: which set to use (options: centroid, fa_standard...)
</li></ul>
<p>Typically, RosettaScripts assumes that poses are all-atom. In some cases, a centroid pose is needed, e.g., for centroid scoring, and this mover is used in those cases.
</p>
<a name="FavorNativeResidue"></a><h4>FavorNativeResidue</h4>
<pre style="white-space:pre-wrap">&lt;FavorNativeResidue bonus=(1.5 &amp;bool)/&gt;</pre>
<p>sets residue_type_constraint to the pose and sets the bonus to 1.5.
</p><p>Note: The use of this mover is somewhat deprecated in favor of FavorSequenceProfile with "scaling=prob matrix=IDENTITY" or with "scaling=none matrix=MATCH"
</p>
<a name="FavorSequenceProfile"></a><h4>FavorSequenceProfile</h4>
<pre style="white-space:pre-wrap">&lt;FavorSequenceProfile scaling=("prob" &amp;string) weight=(1 &amp;Real)  pssm=(&amp;string) use_native=(false &amp;bool) use_starting=(false &amp;bool) use_current=(false &amp;bool) pdbname=(&amp;string) matrix=(BLOSUM62 &amp;string) scorefxns=(comma seperated list of &amp;string)/&gt;</pre>
<p>Sets residue type constraints on the pose according to the given profile and weight.
Set one (and only one) of the following:
</p>
<ul><li> pssm - a filename of a blast formatted pssm file containing the sequence profile to use
</li><li> use_native - use the structure specified by -in:file:native as reference
</li><li> use_starting - use the starting input structure (e.g. one passed to -s) as reference
</li><li> use_current - use the current structure (the one passed to apply) as the reference
</li><li> pdbname - use the structure specified by the filename as the reference
</li></ul>
<p>You can set how to scale the given values with the "scaling" settings. The default value of "prob" does a per-residue Boltzmann-weighted probability based on the profile score (the unweighted scores for all 20 amino acid identities at any given position sum to -1.0). A setting of "global" does a global linear fixed-zero rescaling such that all (pre-weighted) values fall in the range of -1.0 to 1.0. A setting of "none" does no adjustment of values.
</p><p>The parameter "weight" can be used to adjust the post-scaling strength of the constraints. (e.g. at a weight=0.2, global-scaled constraint energies fall in the range of -0.2 to 0.2 and prob-weighted IDENTITY-based constraint energies are in the range of -0.2 to 0, both assuming a res_type_constraint=1) 
</p><p>Note that the weight parameter does not affect the value of res_type_constraint in the scorefunction. As the constraints will only be visible with non-zero res_type_constraint values, the parameter scorefxns is a convenience feature to automatically set res_type_constraint to 1 in the listed functions where it is currently turned off.
</p><p>If a structure is used for input instead of a PSSM, the profile weights used are based off of the given substitution matrix in the database. Current options include:
</p>
<ul><li> MATCH: unscaled/unweighted scores of -1 for an amino acid match and 1 for a mismatch 
</li><li> IDENTITY: unscaled/unweighted scores of -1 for a match and +10000 for a mismatch. Most useful with prob-scaling, giving a prob-scaled/unweighted score of -1.0 for an amino acid match, and 0 for a mismatch.
</li><li> BLOSUM62: Values vary based on aa and substitution. Unnscaled/unweighted scores are mostly in the range of -2 to +4, but range up to -11 and +4.
</li></ul>
<p>NOTE: The default behavior of FavorSequenceProfile has changed from previous versions. If you're using a structure as a reference, you'll want to check your weight, scaling and substitution matrix to make sure your energy values are falling in the appropriate range.
</p>
<a name="SetTemperatureFactor"></a><h4>SetTemperatureFactor</h4>
<p>Set the temperature (b-)factor column in the PDB based on a filter's per-residue information. Useful for coloring a protein based on some energy. The filter should be ResId-enabled (reports per-residue values) or else an error occurs.
</p>
<pre style="white-space:pre-wrap">&lt;SetTemperatureFactor name="&amp;string" filter=(&amp;string) scaling=(1.0&amp;Real)/&gt;</pre>
<ul>
<li> filter: A ResId-compatible filter name
</li><li> scaling: Values reported by the filter will be multiplied by this factor.
</li></ul>
<a name="RollMover"></a><h4>RollMover</h4>
<p>Rotate pose over a given axis.  
</p>
<pre style="white-space:pre-wrap">		&lt;RollMover name=(&amp;string) start_res=(&amp;int) stop_res=(&amp;int) min_angle=(&amp;Real) max_angle=(&amp;Real) &gt; 
		       &lt;axis x=(&amp;Real) y=(&amp;Real) z=(&amp;Real) /&gt; 
		       &lt;translate x=(&amp;Real) y=(&amp;Real) z=(&amp;Real) /&gt; 

		&lt;/RollMover&gt;
</pre>
<ul>
<li> start_res: first residue id of object to roll
</li><li> stop_res: last residue id of object to roll
</li><li> min_angle: minimum angle to roll about axis
</li><li> max_angle: maximum angle to roll about axis
</li><li> axis: vector to rotate about
</li><li> translate: point to translate axis to
</li></ul>
<a name="RemodelMover"></a><h4>RemodelMover</h4>
<p>Remodel and rebuild a protein chain  
</p><p>IMPORTANT NOTE!!!!: Remodel uses an internal system of trajectories controlled by the option -num_trajectory [integer, &gt;= 1]. If num_trajectory &gt; 1 each result is scored with score12 and the pose with lowest energy is handed to the next mover or filter.  -num_trajectory 1 is recommended for rosetta_scripts.
</p>
<pre style="white-space:pre-wrap">		&lt;RemodelMover name=(&amp;string)/&gt; 
</pre>
<ul>
<li> tags coming soon, use flags for now as described in Remodel page <a href="https://wiki.rosettacommons.org/index.php/Remodel" class="external" title="https://wiki.rosettacommons.org/index.php/Remodel">https://wiki.rosettacommons.org/index.php/Remodel</a>
</li></ul>
<a name="Protein_Interface_Design_Movers"></a><h2>Protein Interface Design Movers</h2>
<p>These movers are at least somewhat specific to the design of protein-protein interfaces. Attempting to use them with, for example, protein-DNA complexes may result in unexpected behavior.
</p>
<a name="ProteinInterfaceMS"></a><h4>ProteinInterfaceMS</h4>
<p>Multistate design of a protein interface. The target state is the bound (input) complex and the two competitor states are the unbound partners and the unbound, unfolded partners. Uses genetic algorithms to select, mutate and recombine among a population of starting designed sequences. See Havranek &amp; Harbury NSMB 10, 45 for details.
</p>
<pre style="white-space:pre-wrap">&lt;ProteinInterfaceMS name="&amp;string" generations=(20 &amp;integer) pop_size=(100 &amp;integer) num_packs=(1 &amp;integer) pop_from_ss=(0 &amp;integer) numresults=(1 &amp;integer) fraction_by_recombination=(0.5 &amp;real) mutate_rate=(0.5 &amp;real) boltz_temp=(0.6 &amp;real) anchor_offset=(5.0 &amp;real) checkpoint_prefix=("" &amp;string) gz=(0 &amp;bool) checkpoint_rename=(0 &amp;bool) scorefxn=(score12 &amp;string) unbound=(1 &amp;bool) unfolded=(1&amp;bool) input_is_positive=(1&amp;bool) task_operations=(&amp;comma-delimited list) unbound_for_sequence_profile=(unbound &amp;bool) profile_bump_threshold=(1.0 &amp;Real) compare_to_ground_state=(see below &amp; bool) output_fname_prefix=("" &amp;string)&gt;
   &lt;Positive pdb=(&amp;string) unbound=(0&amp;bool) unfolded=(0&amp;bool)/&gt;
   &lt;Negative pdb=(&amp;string) unbound=(0&amp;bool) unfolded=(0&amp;bool)/&gt;
   .
   .
   .
&lt;/ProteinInterfaceMS&gt;
</pre>
<p>The input file (-s or -l) is considered as either a positive or negative state (depending on option, input_is_positive). If unbound and unfolded is true in the main option line, then the unbound and the unfolded states are added as competitors.
Any number of additional positive and negative states can be added. Unbound and unfolded takes a different meaning for these states: if unbound is checked, the complex will be broken apart and the unbound state will be added. If unfolded is checked, then the unbound and unfolded protein will be added.
</p><p>unbound_for_sequence_profile: use the unbound structure to generate an ala pose and prune out residues that are not allowed would clash in the monomeric structure. Defaults to true, if unbound is used as a competitor state.
profile_bump_threshold: what bump threshold to use above. The difference between the computed bump and the bump in the ala pose is compared to this threshold.
</p><p>compare_to_ground_state: by default, if you add states to the list using the Positive/Negative tags, then the energies of all additional states are zeroed at their 'best-score' values. This allows the user to override this behaviour. See code for details.
</p><p>output_fname_prefix: All of the positive/negative states that are defined by the user will be output at the end of the run using this prefix. Each state will have its sequence changed according to the end sequence and then a repacking and scoring of all states will take place according to the input taskfactory.
</p><p>Rules of thumb for parameter choice. The Fitness F is defined as:
</p>
<pre> F = Sum_+( exp(E/T) ) / ( Sum_+( exp(E/T) ) + Sum_-( exp(E/T) ) + Sum_+((E+anchor)/T) )
</pre>
<p>where Sum_-, and Sum_+ is the sum over the negative and positive states, respectively.
</p><p>the values for F range from 1 (perfect bias towards +state) to 0 (perfect bias towards -state). The return value from the PartitionAggregateFunction::evaluate method is -F, with values ranging from -1 to 0, correspondingly. You can follow the progress of MSD by looking at the reported fitnesses for variants within a population at each generation. If all of the parameters are set properly (temperature etc.) expect to see a wide range of values in generation 1 (-0.99 - 0), which is gradually replaced by higher-fitness variants. At the end of the simulation, the population will have shifted to -1.0 - -0.5 or so.
</p><p>For rules of thumb, it's useful to consider a two-state, +/- problem, ignoring the anchor (see below, that's tantamount to setting anchor very high)
In this case FITNESS simplifies to:
</p>
<pre> F = 1/(exp( (dE)/T ) + 1 )
</pre>
<p>and the derivative is:
</p>
<pre> F' = 1/(T*(exp(-dE/T) + exp(dE/T) + 2)
</pre>
<p>where dE=E_+ - E_-
</p><p>A good value for T would then be such where F' is sizable (let's say more than 0.05) at the dE values that you want to achieve between the positive and negative state. Since solving F' for T is not straightforward, you can plot F and F' at different temperatures to identify a reasonable value for T, where F'(dE, T) is above a certain threshold. If you're lazy like me, set T=dE/3. So, if you want to achieve differences of at least 4.5 e.u between positive and negative states, use T=1.5.
</p><p>To make a plot of these functions use MatLab or some webserver, e.g., <a href="http://www.walterzorn.com/grapher/grapher_e.htm" class="external" title="http://www.walterzorn.com/grapher/grapher_e.htm">http://www.walterzorn.com/grapher/grapher_e.htm</a>.
</p><p>The anchor_offset value is used to set a competitor (negative) state at a certain energy above the best energy of the positive state. This is a computationally cheap assurance that as the specificity changes in favour of the positive state, the stability of the system is not overly compromised. Set anchor_offset to a value that corresponds to the amount of energy that you're willing to forgo in favour of specificity.
</p>
<a name="InterfaceAnalyzerMover"></a><h4>InterfaceAnalyzerMover</h4>
<p>Calculate binding energies, buried interface surface areas, packing statistics, and other useful interface metrics for the evaluation of protein interfaces.
</p>
<pre style="white-space:pre-wrap">&lt;InterfaceAnalyzerMover name="&amp;string" scorefxn=(&amp;string) packstat=(&amp;bool) pack_input=(&amp;bool) pack_separated=(0, &amp;bool) jump=(&amp;int) tracer=(&amp;bool) use_jobname=(&amp;bool) resfile=(&amp;bool) /&gt;
</pre>
<ul>
<li> packstat: activates packstat calculation; can be slow so it defaults to off. See the paper on RosettaHoles to find out more about this statistic (Protein Sci. 2009 Jan;18(1):229-39.) 
</li><li> jump: which jump number should be used to determine across which chains to make the interface? NOT RECOMMENDED - use -fixedchains instead.
</li><li> tracer: print to a tracer (true) or a scorefile (false)? Combine the true version with -out:jd2:no_output and the false with out:file:score_only (scorefile).
</li><li> use_jobname: use_jobname (bool) - if using tracer output, this turns the tracer name into the name of the job. If you run this code on 50 inputs, the tracer name will change to match the input, labeling each line of output with the input to which it applies. Not relevant if not using tracer output.
</li><li> pack_separated: repack the exposed interfaces when calculating binding energy? Usually a good idea. 
</li><li> resfile: warns the protocol to watch for the existence of a resfile if it is supposed to do any packing steps. (This is normally signealed by the existance of the -resfile flag, but here the underlying InterfaceAnalyzerMover is not intended to use -resfile under normal circumstances, so a separate flag is needed. You can still pass the resfile with -resfile.)
</li><li> pack_input: prepack before separating chains when calculating binding energy? Useful if these are non-Rosetta inputs 
</li></ul>
<a name="Docking"></a><h4>Docking</h4>
<p>Does both centroid and full-atom docking
</p>
<pre style="white-space:pre-wrap">&lt;Docking name="&amp;string" score_low=(score_docking_low &amp;string) score_high=(score12 &amp;string) fullatom=(0 &amp;bool) local_refine=(0 &amp;bool) jumps=(1 &amp;Integer vector) optimize_fold_tree=(1 &amp;bool) conserve_foldtree=(0 &amp;bool) design=(0 &amp;bool) ignore_default_docking_task=(0 &amp;bool) task_operations=("" comma-separated list)/&gt;
</pre>
<ul>
<li>score_low is the scorefxn to be used for centroid-level docking
</li><li>score_high is the scorefxn to be used for full atom docking
</li><li>fullatom: if true, do full atom docking
</li><li>local_refine: if true, skip centroid. Note that fullatom=0 and local_refine=1 together will result in NO DOCKING!
</li><li>jumps is a comma-separated list of jump numbers over which to carry out rb motions
</li><li>optimize_fold_tree: should DockingProtocol make the fold tree for this pose? This should be turned to 0 only if AtomTree is used
</li><li>conserve_foldtree: should DockingProtocol reset the fold tree to the input one after it is done
</li><li>design: Enable interface design for all chains downstream of the rb_jump
</li><li>ignore_default_docking_task: allows you to ignore the default docking task and only use the ones defined in your task_operations section
</li></ul>
<a name="Prepack"></a><h4>Prepack</h4>
<p>Performs something approximating r++ prepacking (but less rigorously without rotamer-trial minimization) by doing sc minimization and repacking. Separates chains based on jump_num, does prepacking, then reforms the complex. If jump_num=0, then it will NOT separate chains at all.
</p>
<pre style="white-space:pre-wrap">&lt;Prepack name=(&amp;string) scorefxn=(score12 &amp;string) jump_number=(1 &amp;integer) task_operations=(comma-delimited list) min_bb=(0 &amp;bool)/&gt;
  &lt;MoveMap&gt;
  ...
  &lt;/MoveMap&gt;
&lt;/Prepack&gt;
</pre>
<ul>
<li> min_bb: minimize backbone in the bound state, before separating the partners. This option activates MoveMap parsing.
</li><li> MoveMap: just like in FastRelax and MinMover, but is only activated if min_bb is set to true.
</li></ul>
<a name="RepackMinimize"></a><h4>RepackMinimize</h4>
<p>RepackMinimize does the design/repack and minimization steps using different score functions as defined by the protocol. For most purposes, the combination of PackRotamersMover with MinMover provide more flexibility and transparency than RepackMinimize, and are advised.
</p><p>repack_partner1 (and 2) defines which of the partners to design. If no particular residues are defined, the interface is repacked/designs. If specific residues are defined, then a shell of residues around those target residues are repacked/designed and minimized. repack_non_ala decides whether or not to change positions that are not ala. Useful for designing an ala_pose so that positions that have been changed in previous steps are not redesigned. min_rigid_body minimize rigid body orientation. (as in docking) 
</p>
<pre style="white-space:pre-wrap">&lt;RepackMinimize name="&amp;string" scorefxn_repack=(score12 &amp;string) scorefxn_minimize=(score12 &amp;string) repack_partner1=(1 &amp;bool) repack_partner2=(1 &amp;bool) design_partner1=(0 &amp;bool) design_partner2=(1 &amp;bool) interface_cutoff_distance=(8.0 &amp;Real) repack_non_ala=(1 &amp;bool) minimize_bb=(1 &amp;bool * see below for more details) minimize_rb=(1 &amp;bool) minimize_sc=(1 &amp;bool) optimize_fold_tree=(1 &amp; bool) task_operations=("" &amp;string)&gt;
    &lt;residue pdb_num/res_num, see below/&gt;
&lt;/RepackMinimize&gt;</pre>
<ul>
<li>scorefxn_repack
</li><li>scorefxn_minimize
</li><li>interface_cutoff_distance: Residues farther away from the interface than this cutoff will not be designed or minimized.
</li><li>repack_non_ala: if true, change positions that are not ala. if false, leave non-ala positions alone. Useful for designing an ala_pose so that positions that have been changed in previous steps are not redesigned. 
</li><li>minimize_bb*: minimize back bone conformation? (*see line below)
</li><li>minimize_bb_ch1 and/or minimize_bb_ch2: allows to specify which chain(s)' backbone will be minimized
</li><li>minimize_rb: minimize rigid body orientation? (as in docking)
</li><li>optimize_fold_tree: see above
</li><li>task_operations: comma-separated list of task operations. This is a safer way of working with user-defined restrictions than automatic_repacking=false.

</li></ul>
<p>If no repack_partner1/2 options are set, you can specify repack=0/1 to control both. Similarly with design_partner1/2 and design=0/1
</p>
<a name="DesignMinimizeHBonds"></a><h4>DesignMinimizeHBonds</h4>
<p>Same as for RepackMinimize with the addition that a list of target residues to be hbonded can be defined. Within a sphere of 'interface_cutoff_distance' of the target residues,the residues will be set to be designed.The residues that are allowed for design are restricted to hbonding residues according to whether donors (STRKWYQN) or acceptors (EDQNSTY) or both are defined. If residues have been designed that do not, after design, form hbonds to the target residues with energies lower than the hbond_energy, then those are turned to Ala. 
</p>
<pre style="white-space:pre-wrap">&lt;DesignMinimizeHbonds name=(design_minimize_hbonds &amp;string) hbond_weight=(3.0 &amp;float) scorefxn_design=(score12 &amp;string) scorefxn_minimize=score12) donors="design donors? &amp;bool" acceptors="design acceptors? &amp;bool" bb_hbond=(0 &amp;bool) sc_hbond=(1 &amp;bool) hbond_energy=(-0.5 &amp;float) interface_cutoff_distance=(8.0 &amp;float) repack_partner1=(1 &amp;bool) repack_partner2=(1 &amp;bool) design_partner1=(0 &amp;bool) design_partner2=(1 &amp;bool) repack_non_ala=(1 &amp;bool) min_rigid_body=(1 &amp;bool) task_operations=("" &amp;string)&gt;
        &lt;residue pdb_num="pdb residue and chain, e.g., 31B &amp;string"/&gt;
        &lt;residue res_num="serially defined residue number, e.g., 212 &amp;integer"/&gt;
&lt;/DesignMinimizeHbonds&gt;
</pre>
<ul>
<li>hbond_weight:            sets the increase (in folds) of the hbonding terms in each of the scorefunctions that are defined.
</li><li>bb_hbond:                do backbone-backbone hbonds count?
</li><li>sc_hbond:                do backbone-sidechain and sidechain-sidechain hbonds count?
</li><li>hbond_energy:            what is the energy threshold below which an hbond is counted as such.
</li><li>repack_non_ala,task_operations:see RepackMinimize
</li><li>optimize_fold_tree:      see DockingProtocol
</li></ul>
<a name="build_Ala_pose"></a><h4>build_Ala_pose</h4>
<p>Turns either or both sides of an interface to Alanines (except for prolines and glycines that are left as in input) in a sphere of 'interface_distance_cutoff' around the interface. Useful as a step before design steps that try to optimize a particular part of the interface. The alanines are less likely to 'get in the way' of really good rotamers.
</p>
<pre style="white-space:pre-wrap">&lt;build_Ala_pose name=(ala_pose &amp;string) partner1=(0 &amp;bool) partner2=(1 &amp;bool) interface_distance_cutoff=(8.0 &amp;float) task_operations=("" &amp;string)/&gt;</pre>
<ul>
<li> task_operations: see <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#RepackMinimize" title="">RepackMinimize</a>
</li></ul>
<a name="SaveAndRetrieveSidechains"></a><h4>SaveAndRetrieveSidechains</h4>
<p>To be used after an ala pose was built (and the design moves are done) to retrieve the sidechains from the
input pose that were set to Ala by build_Ala_pose. OR, to be used inside mini to recover sidechains after switching residue typesets. By default, sidechains that are different than Ala will not be changed, <b>unless</b> allsc is true.
Please note that naming your mover "SARS" is almost certainly bad luck and strongly discouraged.
</p>
<pre>&lt;SaveAndRetrieveSidechains name=(save_and_retrieve_sidechains &amp;string) allsc=(0 &amp;bool) task_operations=("" &amp;string)/&gt;</pre>
<ul>
<li> task_operations: see <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#RepackMinimize" title="">RepackMinimize</a>
</li></ul>
<a name="AtomTree"></a><h4>AtomTree</h4>
<p>Sets up an atom tree for use with subsequent movers.
Connects pdb_num on host_chain to the nearest residue on the neighboring chain. Connection is made through connect_to on host_chain pdb_num residue
</p>
<pre style="white-space:pre-wrap">&lt;AtomTree name=(&amp;string) docking_ft=(0 &amp;bool) pdb_num/res_num=(see above) connect_to=(see below for defaults &amp;string) anchor_res=(pdb numbering) connect_from=(see below) host_chain=(2 &amp;integer) simple_ft=(0&amp;bool)/&gt;</pre>
<ul>
Simple preset versions for a foldtree:
<br>

<li> docking_ft: set up a docking foldtree? if this is set all other options are ignored.
</li><li> simple_ft: set a simple ft going from 1-&gt;chain1_end; 1-&gt;chain2_begin; chain2_begin-&gt;chain2_end; etc.
<br><br>
Detailed settings for a foldtree:
<br> 
These options specify the actual jump atoms. anchor_res (this is the residue) and connect_from (the actual atom) are a pair and are used for the first chain, whereas pdb_num (residue) and connect_to (atom) are a pair on chain 2 (the one that typically moves)  
</li><li> connect_to: Defaults to using the farthest carbon atom from the mainchain for each residue, e.g., CB, Cdelta for Gln etc.
</li><li> connect_from: user can specify which atom the jump should start from. Currently only the pdb naming works. If not specified, the "optimal" atomic connection for anchor residue is chosen (that is to their functional groups).
</li></ul>
<a name="SpinMover"></a><h4>SpinMover</h4>
<p>Allows random spin around an axis that is defined by the jump. Works preferentially good in combination with a loopOver or best a GenericMonteCarlo and other movers together. Use SetAtomTree to define the jump atoms. 
</p>
<pre style="white-space:pre-wrap">&lt;SpinMover name=(&amp;string) jump_num=(1 &amp;integer)/&gt;</pre>
<a name="TryRotamers"></a><h4>TryRotamers</h4>
<p>Produces a set of rotamers from a given residue. Use after <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#AtomTree" title="">AtomTree</a> to generate inverse rotamers of a given residue.
</p>
<pre style="white-space:pre-wrap">&lt;TryRotamers name=(&amp;string) pdb_num/res_num=(see above) automatic_connection=(1 &amp;bool) jump_num=(1, &amp;Integer) scorefxn=(score12 &amp;string) explosion=(0 &amp;integer) shove=(&amp;comma-separated residue identities)/&gt;
</pre>
<ul>
<li>explosion: range from 0-4 for how much extra rotamer explosion to include. Extra explosion in this context means EX_FOUR_HALF_STEP_STDDEVS (+/- 0.5, 1.0, 1.5, 2.0 sd). (By default EX_ONE_STDDEV (+/- 1.0 sd) is included for all chi1,2,3,4.)
        <ul><li>1 = explode chi1
        </li><li>2 = explode chi1,2
        </li><li>3 = explode chi1,2,3
        </li><li>4 = explode chi1,2,3,4
        </li></ul>
</li><li> shove: use the shove atom-type (reducing the repulsive potential on backbone atoms) for a comma-separated list of residue identities. e.g., shove=3A,40B.
</li><li> automatic_connection: should TryRotamers set up the inverse-rotamer fold tree independently?
</li></ul>
<p>Each pass through TryRotamers will place the next rotamer at the given position. Increase -nstruct settings appropriately to obtain them all. Once all rotamers have been placed, TryRotamers will cause subsequent runs through the protocol with the same settings to fail.
</p>
<a name="BackrubDD"></a><h4>BackrubDD</h4>
<p>Do backrub-style backbone and sidechain sampling.
</p>
<pre style="white-space:pre-wrap">&lt;BackrubDD name=(backrub &amp;string) partner1=(0 &amp;bool) partner2=(1 &amp;bool) interface_distance_cutoff=(8.0 &amp;Real) moves=(1000 &amp;integer) sc_move_probability=(0.25 &amp;float) scorefxn=(score12 &amp;string) small_move_probability=(0.0 &amp;float) bbg_move_probability=(0.25 &amp;float) temperature=(0.6 &amp;float) task_operations=("" &amp;string)&gt;
        &lt;residue pdb_num="pdb residue and chain, e.g., 31B &amp;string"/&gt;
        &lt;residue res_num="serially defined residue number, e.g., 212 &amp;integer"/&gt;
        &lt;span begin="pdb or rosetta-indexed number, eg 10 or 12B &amp;string" end="pdb or rosetta-indexed number, e.g., 20 or 30B &amp;string"/&gt;
&lt;/BackrubDD&gt;
</pre>
<p>With the values defined above, backrub will only happen on residues 31B, serial 212, and the serial span
10-20. If no residues and spans are defined then all of the interface residues on the defined partner
will be backrubbed by default.
Note that setting partner1=1 makes all of partner1 flexible.
Adding segments has the effect of adding these spans to the default interface definition
Temperature controls the monte-carlo accept temperature. A setting of 0.1 allows only very small moves, where as 0.6 (the default) allows more exploration.
Note that small moves and bbg_moves introduce motions that, unlike backrub, are not confined to the region that is being manipulated and can cause downstream structural elements to move as well. This might cause large lever motions if the epitope that is being manipulated is a hinge. To prevent lever effects, all residues in a chain that is allowed to backrub will be subject to small moves. Set small_move_probability=0 and bbg_move_probability=0 to eliminate such motions.
</p><p>bbg_moves are backbone-Gaussian moves. See The J. Chem. Phys., Vol. 114, pp. 8154-8158.
</p><p>Note: As of June 29, 2011, this mover was renamed from "Backrub" to "BackrubDD". Scripts run with versions of Rosetta after that date must be updated accordingly.
</p>
<ul>
<li> task_operations: see <a href="http://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/Movers_%28RosettaScripts%29#RepackMinimize" title="">RepackMinimize</a>
</li></ul>
<a name="BestHotspotCst"></a><h4>BestHotspotCst</h4>
<p>Removes Hotspot BackboneStub constraints from all but the best_n residues, then reapplies constraints to only those best_n residues with the given cb_force constant. Useful to prune down a hotspot-derived constraint set to avoid getting multiple residues getting frustrated during minimization.
</p>
<pre style="white-space:pre-wrap">&lt;BestHotspotCst name=(&amp;string) chain_to_design=(2 &amp;integer) best_n=(3 &amp;integer) cb_force=(1.0 &amp;Real)/&gt;</pre>
<ul>
<li>best_n: how many residues to cherry-pick. If there are fewer than best_n residues with constraints, only those few residues will be chosen.
</li><li>chain_to_design: which chain to reapply constraints
</li><li>cb_force: Cbeta force to use when reapplying constraints
</li></ul>
<a name="DomainAssembly_.28Not_tested_thoroughly.29"></a><h4>DomainAssembly (Not tested thoroughly)</h4>
<p>Do domain-assembly sampling by fragment insertion in a linker region. frag3 and frag9 specify the fragment-file names for 9-mer and 3-mer fragments.
</p>
<pre style="white-space:pre-wrap">&lt;DomainAssembly name=(&amp;string) linker_start_(pdb_num/res_num, see above) linker_end_(pdb_num/res_num, see above) frag3=(&amp;string) frag9=(&amp;string)/&gt;</pre>
<a name="LoopFinder"></a><h4>LoopFinder</h4>
<p>Finds loops in the current pose and loads them into the DataMap for use by subsequent movers (eg - LoopRemodel)
</p>
<pre>&lt;LoopFinder name="&amp;string" interface=(1 &amp;Size) ch1=(0 &amp;bool) ch2=(1 &amp;bool) min_length=(3 &amp;Integer)
 max_length=(1000 &amp;Integer) iface_cutoff=(8.0 &amp;Real) resnum/pdb_num=(see above) 
CA_CA_distance=(15.0 &amp;Real) mingap=(1 &amp;Size)/&gt;</pre>
<ul>
<li>interface: only keep loops at the interface? value = jump number to use (0 = keep all loops)
</li><li>ch1: keep loops on partner 1
</li><li>ch2: keep loops on partner 2
</li><li>resnum/pdb_num: if specified, loop finder only takes the loops that are within the defined CA_CA_distance. If this option is occluded, it extracts loops given by chain1, chain2 and interface options.So occlude if you don't know the residue.
</li><li>CA_CA_distance: cutoff for CA distances between defined residue and any interface loop residue 
</li><li>iface_cutoff: distance cutoff for interface
</li><li>min_length: minimum loop length (inclusive)
</li><li>max_length: maximum loop length (inclusive)
</li><li>mingap: minimum gap size between loops (exclusive, so mingap=1 -&gt; single-residue gaps are disallowed). Setting this to 0 will almost certainly cause problems!
</li></ul>
<a name="LoopRemodel"></a><h4>LoopRemodel</h4>
<p>Perturbs and/or refines a set of user-defined loops. Useful to sample a variety of loop conformations.
</p>
<pre style="white-space:pre-wrap">&lt;LoopRemodel name="&amp;string" auto_loops=(0 &amp;bool) loop_start_(pdb_num/res_num, see above) loop_end_(pdb_num/res_num, see above) hurry=(0 &amp;bool) cycles=(10 &amp;Size) protocol=(ccd &amp;string) perturb_score=(score4L &amp;string) refine_score=(score12 &amp;string) perturb=(0 &amp;bool) refine=(1 &amp;bool) design=(0 &amp;bool)/&gt;
</pre>
<ul>
<li>
</li><li>auto_loops: use loops defined by previous LoopFinder mover? (overrides loop_start/end)
</li><li>loop_start_pdb_num: start of the loop
</li><li>loop_end_pdb_num: end of the loop
</li><li>hurry: 1 = fast sampling and minimization. 0 = Use full-blown loop remodeling.
</li><li>cycles: if hurry=1, number of modeling cycles to perform. Each cycle is 50 steps of mc-accepted kinematic loop modeling, followed by a repack of the surrounding area. if hurry=0 and protocol=remodel, this controls the max number of times to attempt closure with the remodel protocol (low cycles might leave chain breaks!)
</li><li>protocol: Only activated if hurry=0. Choose "kinematic", "ccd", or "remodel". ccd appears to work best at the moment.
</li><li>perturb_score: scorefunction to use for loop perturbation
</li><li>refine_score: scorefunction to use for loop refinement
</li><li>perturb: perturb loops for greater diversity?
</li><li>refine: refine loops?
</li><li>design: perform design during loop modeling?
</li></ul>
<a name="LoopMoverFromCommandLine"></a><h4>LoopMoverFromCommandLine</h4>
<p>Perturbs and/or refines a set of loops from a loop file. Also takes in fragment libraries from command line (-loops:frag_sizes , -loops:frag_files). Has kinematic, ccd and automatic protocols. 
</p>
<pre style="white-space:pre-wrap">&lt;LoopMoverFromCommandLine name="&amp;string" loop_file=("loop.loops" &amp;string) protocol=(ccd &amp;string) perturb_score=(score4L &amp;string) refine_score=(score12 &amp;string) perturb=(0 &amp;bool) refine=(1 &amp;bool)/&gt;
</pre>
<ul>
<li>protocol: Only activated if hurry=0. Choose "automatic", "kinematic" or "ccd".If you set automatic, this mover becomes a wrapper around the 'modern' version of LoopRemodelMover which has all of the loop options defined within it. This is the recommended way of activating this mover. If you do that, then you get access to the following string options: relax (no,&amp;string), refine (ccd is best), intermedrelax (no is default and is best), remodel (quick_ccd is best).
</li><li>perturb_score: scorefunction to use for loop perturbation
</li><li>refine_score: scorefunction to use for loop refinement
</li><li>perturb: perturb loops for greater diversity?
</li><li>refine: refine loops?
</li><li>loop_file: loop file that should be in current working directory using minirosetta loop format.
</li></ul>
<p>For protocol="automatic"  (Based on Loop Modeling Application and LoopRemodel):
</p>
<pre style="white-space:pre-wrap">&lt;LoopMoverFromCommandLine name="&amp;string" loop_file=("loop.loops" &amp;string) protocol=automatic perturb_score=(score4L &amp;string) refine_score=(score12 &amp;string) perturb=(0 &amp;bool) refine=(no &amp;string) remodel=(quick_ccd &amp;string) relax=(no, &amp;string) intermedrelax=(no &amp;string)/&gt;
</pre>
<ul>
<li>refine:'no','refine_ccd','refine_kic'. This option controls the fullatom refinement stage of loop modeling.
</li><li>remodel:'no','perturb_ccd','perturb_kic','quick_ccd','quick_ccd_moves','old_loop_relax'.
</li><li>relax:'no','fastrelax','shortrelax','full relax'. Controls whether a full-structure relax occurs after loop modeling.
</li><li>intermedrelax: Currently not used; eventually may provide for a full-pose relax between centroid and full atom modeling.
</li></ul>
<a name="DisulfideMover"></a><h4>DisulfideMover</h4>
<p>Introduces a disulfide bond into the interface. The best-scoring position for the disulfide bond is selected from among the residues listed in <code>targets</code>. This could be quite time-consuming, so specifying a small number of residues in <code>targets</code> is suggested.
</p><p>If no targets are specified on either interface partner, all residues on that partner are considered when searching for a disulfide. Thus including only a single residue for <code>targets</code> results in a disulfide from that residue to the best position across the interface from it, and omitting the <code>targets</code> param altogether finds the best disulfide over the whole interface.
</p><p>Disulfide bonds created by this mover, if any, are guaranteed to pass a DisulfideFilter.
</p>
<pre style="white-space:pre-wrap">&lt;DisulfideMover name="&amp;string" targets=(&amp;string)/&gt;</pre>
<ul><li> targets: A comma-seperated list of residue numbers. These can be either with rosetta numbering (raw integer) or pdb numbering (integer followed by the chain letter, eg '123A'). Targets are required to be located in the interface. Default: All residues in the interface. <em>Optional</em>
</li></ul>
<a name="MutateResidue"></a><h4>MutateResidue</h4>
<p>Change a single residue to a different type. For instance, mutate Arg31 to an Asp.
</p>
<pre style="white-space:pre-wrap">&lt;MutateResidue name=(&amp;string) target=(&amp;string) new_res=(&amp;string) /&gt;</pre>
<ul><li> target The location to mutate (eg 31A (pdb number) or 177 (rosetta index)). <i>Required</i>
</li><li> new_res The name of the residue to introduce. This string should correspond to the ResidueType::name() function (eg ASP). <i>Required</i>
</li></ul>
<a name="InterfaceRecapitulation"></a><h4>InterfaceRecapitulation</h4>
<p>Test a design mover for its recapitulation of the native sequence. Similar to SequenceRecovery filter below, except that this mover encompasses a design mover more specifically.
</p>
<pre style="white-space:pre-wrap">&lt;InterfaceRecapitulation name=(&amp;string) mover_name=(&amp;string)/&gt;</pre>
<p>The specified mover needs to be derived from either DesignRepackMover or PackRotamersMover base class and to to have the packer task show which residues have been designed. The mover then computes how many residues were allowed to be designed and the number of residues that have changed and produces the sequence recapitulation rate. The pose at parse-time is used for the comparison.
</p>
<a name="VLB_.28aka_Variable_Length_Build.29"></a><h4>VLB (aka Variable Length Build) </h4>
<p>Under development! All kudos to Andrew Ban of the Schief lab for making the 
Insert, delete, and rebuild segments of variable length.
This mover will ONLY work with non-overlapping segments!
</p><p><b>IMPORTANT NOTE!!!!</b>: VLB uses its own internal tracking of ntrials! This allows VLB to cache fragments between ntrials, saving a very significant amount of time. But each ntrial trajectory will also get ntrials extra internal VLB apply calls. For example, "-jd2:ntrials 5" will cause a maximum of 25 VLB runs (5 for each ntrial). Success of a VLB move will break out of this internal loop, allowing the trajectory to proceed as normal.
</p>
<pre style="white-space:pre-wrap">&lt;VLB name=(&amp;string) scorefxn=(string)&gt;
    &lt;VLB TYPES GO HERE/&gt;
&lt;/VLB&gt;
Default scorefxn is score4L. If you use another scorefxn, make sure the chainbreak weight is &gt; 0. Do not use a full atom scorefxn with VLB!
</pre>
<p>There are several move types available to VLB, each with its own options.
The most popular movers will probably be SegmentRebuild and SegmentInsert.
</p>
<pre style="white-space:pre-wrap">
&lt;SegmentInsert left=(&amp;integer) right=(&amp;integer) ss=(&amp;string) aa=(&amp;string) pdb=(&amp;string) side=(&amp;string) keep_bb_torsions=(&amp;bool)/&gt; 

Insert a pdb into an existing pose. To perform a pure insertion without replacing any residues within a region, use an interval with a zero as the left endpoint.
e.g. [0, insert_after_this_residue].
If inserting before the first residue the Pose then interval = [0,0].  If inserting after the last residue of the Pose then interval = [0, last_residue]. 

*ss = secondary structure specifying the flanking regions, with a character '^' specifying where the insert is to be placed. Default is L^L.
*aa = amino acids specifying the flanking regions, with a character '^' specifying insert.
*keep_bb_torsions = attempt to keep the a few torsions from around the insert. This should be false for pure insertions. (default false)
*side = specifies insertion on its N-side ("N"), C-side ("C") or decide randomly between the two (default "RANDOM"). Random is only random on parsing, not per ntrial

</pre>
<pre style="white-space:pre-wrap">
&lt;SegmentRebuild left=(&amp;integer) right=(&amp;integer) ss=(&amp;string) aa=(&amp;string)/&gt; 
Instruction to rebuild a segment. Can also be used to insert a segment, by specifying secondary structure longer than the original segment.
</pre>
<pre style="white-space:pre-wrap">Very touchy. Watch out.
&lt;SegmentSwap left=(&amp;integer) right=(&amp;integer) pdb=(&amp;string)/&gt; instruction to swap a segment with an external pdb
</pre>
<pre style="white-space:pre-wrap">&lt;Bridge left=(&amp;integer) right=(&amp;integer) ss=(&amp;string) aa=(&amp;string)/&gt; connect two contiguous but disjoint sections of a
                       Pose into one continuous section
</pre>
<pre style="white-space:pre-wrap">&lt;ConnectRight left=(&amp;integer) right=(&amp;integer) pdb=(&amp;string)/&gt; instruction to connect one PDB onto the right side of another
</pre>
<pre style="white-space:pre-wrap">&lt;GrowLeft pos=(&amp;integer) ss=(&amp;string) aa=(&amp;string)/&gt; Use this for n-side insertions, but typically not n-terminal
			extensions unless necessary.  It does not automatically cover the
			additional residue on the right endpoint that needs to move during
			n-terminal extensions due to invalid phi torsion.  For that case,
			use the SegmentRebuild class replacing the n-terminal residue with
			desired length+1.
</pre>
<pre style="white-space:pre-wrap">&lt;GrowRight pos=(&amp;integer) ss=(&amp;string) aa=(&amp;string)/&gt; instruction to create a c-side extension
</pre>
<p>For more information, see the various BuildInstructions in src/protocols/forge/build/
</p>
<a name="Computational_.27affinity_maturation.27_movers_.28highly_experimental.29"></a><h3>Computational 'affinity maturation' movers (highly experimental)</h3>
<p>These movers are meant to take an existing complex and improve it by subtly changing all relevant degrees of freedom while optimizing the interactions of key sidechains with the target. The basic idea is to carry out iterations of relax and design of the binder, designing a large sphere of residues around the interface (to get second/third shell effects).
</p><p>We start by generating high affinity residue interactions between the design and the target. The foldtree of the design is cut such that each target residue has a cut N- and C-terminally to it, and jumps are introduced from the target protein to the target residues on the design, and then the system is allowed to relax. This produces deformed designs with high-affinity interactions to the target surface. We then use the coordinates of the target residues to generate harmonic coordinate restraints and send this to a second cycle of relax, this time without deforming the backbone of the design. Example scripts are available in demo/rosetta_scripts/computational_affinity_maturation/
</p>
<a name="RandomMutation"></a><h4>RandomMutation</h4>
<p>Introduce a random mutation in a position allowed to redesign to an allowed residue identity. Control the residues and the target identities through <tt>task_operations</tt>. The protein will be repacked according to <tt>task_operations</tt> and <tt>scorefxn</tt> to accommodate the mutated amino acid. The mover can work with symmetry poses; simply use SetupForSymmetry and run. It will figure out that it needs to do symmetric packing for itself.
</p><p>This can be used in conjunction with GenericMonteCarlo to generate trajectories of affinity maturation.
</p>
<pre style="white-space:pre-wrap">&lt;RandomMutation name=(&amp;string) task_operations=(&amp;string comma-separated taskoperations) scorefxn=(score12 &amp;string)/&gt;</pre>
<a name="GreedyOptMutationMover"></a><h4>GreedyOptMutationMover</h4>
<p>This mover will first attempt isolated/independent mutations defined in the input task operation, score/filter them all, rank them by score, then attempt to combine them, starting with the best scoring single mutation, accepting the mutation only if the filter score decreases, and working down the list to the end. 
</p><p>Necessary:
</p>
<ul>
<li> task_operations: defines designable positions and identities
</li><li> filter: defines the score you're trying to optimize (and a cutoff), defaults to lower = better
</li><li> relax_mover: a mover for post-repacking relaxation (e.g. minimization)
</li></ul>
<p>Optional:
</p>
<ul>
<li> if your filter values are such that higher = better, use "sample_type=high"
</li><li> if you want to see a pdb of every trial mutation, add "dump_pdb=1"
</li><li> stopping_condition: stops before trials are done if a filter evaluates to true.
</li></ul>
<pre style="white-space:pre-wrap">&lt;GreedyOptMutationMover name=(&amp;string) task_operations=(&amp;string comma-separated taskoperations) filter=(&amp;string) scorefxn=(score12 &amp;string) relax_mover=(&amp;string) sample_type=(low &amp;string) dump_pdb=(0 &amp;bool) stopping_condition=("" &amp;string)/&gt;</pre>
<a name="HotspotDisjointedFoldTree"></a><h4>HotspotDisjointedFoldTree</h4>
<p>Creates a disjointed foldtree where each selected residue has cuts N- and C-terminally to it.
</p>
<pre style="white-space:pre-wrap">&lt;HotspotDisjointedFoldTree name=(&amp;string) ddG_threshold=(1.0 &amp;Real) resnums=("" comma-delimited list of residues &amp;string) scorefxn=(score12 &amp;string) chain=(2 &amp;Integer) radius=(8.0 &amp;Real)/&gt;</pre>
<ul>
<li> ddG_threshold: The procedure can look for hot-spot residues automatically by using this threshold. If you want to shut it off, specify a number above 100R.e.u. and set the residues in resnums
</li><li> chain: Anything other than chain 1 is untested, but should not be a big problem to make work.
</li><li> radius: what distance from the target protein constitutes interface. Used in conjunction with the ddG_threshold to set the target residues automatically.
</li></ul>
<a name="AddSidechainConstraintsToHotspots"></a><h4>AddSidechainConstraintsToHotspots</h4>
<p>Adds harmonic constraints to sidechain atoms of target residues (to be used in conjunction with HotspotDisjointedFoldTree). Save the log files as those would be necessary for the next stage in affinity maturation.
</p>
<pre style="white-space:pre-wrap">&lt;AddSidechainConstraintsToHotspots name=(&amp;string) chain=(2 &amp;Integer) coord_sdev=(1.0 &amp;Real) resnums=(comma-delimited list of residue numbers)/&gt;
</pre>
<ul>
<li> resnums: the residues for which to add constraints. Notice that this list will be treated in addition to any residues that have cut points on either side.
</li><li> coord_sdev: the standard deviation on the coordinate restraints. The lower the tighter the restraints.
</li></ul>
<a name="Placement_and_Placement-associated_Movers_.26_Filters"></a><h3>Placement and Placement-associated Movers &amp; Filters</h3>
<p>The placement method has been described in:
</p><p>Fleishman, SJ, Whitehead TA, et al. Science 332, 816-821. (2011)
and
JMB 413:1047
</p><p>The objective of the placement methods are to help in the task of generating hot-spot based designs of protein binders. The starting point for all of them are a protein target (typically chain A), libraries of hot-spot residues, and a scaffold protein.
</p><p>A few keywords used throughout the following section have special meaning and are briefly explained here.
</p>
<ul>
<li> Hot-spot residue: typically a residue that forms optimized interactions with the target protein. The goal here is to find a low-energy conformation of the scaffold protein that incorporates as many such hot-spot residues as possible.
</li><li> Stub: used interchangeably with hot-spot residue. This is a dismembered residue in a specified location against the target surface.
</li><li> Placement: positioning of the scaffold protein such that it incorporates the hot-spot residue optimally.
</li></ul>
<p>Hotspot residue-libraries can be read once by the SetupHotspotConstraintsMover. In this mover you can decide how many hotspot residues will be kept in memory for a given run. This number of residues will be chosen randomly from the residues that were read. In this way, you can read arbitrarily large hotspot residue libraries, but each trajectory will only iterate over a smaller set.
</p>
<a name="Auction"></a><h4>Auction</h4>
<p>This is a special mover associated with PlaceSimultaneously, below. It carries out the auctioning of residues on the scaffold to hotspot sets without actually designing the scaffold. If pairing is unsuccessful Auction will report failure.
</p>
<pre style="white-space:pre-wrap">&lt;Auction name=( &amp;string) host_chain=(2 &amp;integer) max_cb_dist=(3.0 &amp;Real) cb_force=(0.5 &amp;Real)&gt;
   &lt;StubSets&gt;
     &lt;Add stubfile=(&amp;string)/&gt;
   &lt;/StubSets&gt;
&lt;/Auction&gt;
</pre>
<p>Note that none of the options, except for name, needs to be set up by the user if PlaceSimultaneously is notified of it. If PlaceSimultaneously is notified of this Auction mover, PlaceSimultaneously will set all of these options.
</p>
<a name="MapHotspot"></a><h4>MapHotspot</h4>
<p>Map out the residues that might serve as a hotspot region on a target. This requires massive user guidance. Each hot-spot residue should be roughly placed by the user (at least as backbone) against the target. Each hot-spot residue should have a different chain ID. The method iterates over all allowed residue identities and all allowed rotamers for each residue. Tests its filters and for the subset that pass selects the lowest-energy residue by score12. Once the first hot-spot residue is identified it iterates over the next and so on until all hot-spot residues are placed. The output contains one file per residue identity combination.
</p>
<pre style="white-space:pre-wrap">&lt;MapHotspot name="&amp;string" clash_check=(0 &amp;bool) file_name_prefix=(map_hs &amp;string)&gt;
   &lt;Jumps&gt;
     &lt;Add jump=(&amp;integer) explosion=(0 &amp;integer) filter_name=(true_filter &amp; string) allowed_aas=("ADEFIKLMNQRSTVWY" &amp;string) scorefxn_minimize=(score12 &amp;string) mover_name=(null &amp;string)/&gt;
     ....
   &lt;/Jumps&gt;
&lt;/MapHotspot&gt;
</pre>
<ul>
<li>
</li><li>clash_check: whether the rotamer set is prescreened by the packer for clashes. Advised to be off always.
</li><li>file_name_prefix: Prefix for the output file names.
</li><li>explosion: How many chi angles to explode (giving more rotamers.
</li><li>allowed_aas: 1-letter codes for the allowed residues.
</li><li>scorefxn_minimize: which scorefxn to use during rb/sc minimization.
</li><li>mover_name: a mover (no restrictions) to run just before hot-spot residue minimization.
</li></ul>
<a name="PlacementMinimization"></a><h4>PlacementMinimization</h4>
<p>This is a special mover associated with PlaceSimultaneously, below. It carries out the rigid-body minimization towards all of the stubsets.
</p>
<pre style="white-space:pre-wrap">&lt;PlacementMinimization name=( &amp;string) minimize_rb=(1 &amp;bool) host_chain=(2 &amp;integer) optimize_foldtree=(0 &amp;bool) cb_force=(0.5 &amp;Real)&gt;
  &lt;StubSets&gt;
    &lt;Add stubfile=(&amp;string)/&gt;
  &lt;/StubSets&gt;
&lt;/PlacementMinimization&gt;
</pre>
<a name="PlaceOnLoop"></a><h4>PlaceOnLoop</h4>
<p>Remodels loops using kinematic loop closure, including insertion and deletion of residues. Handles hotspot constraint application through these sequence changes.
</p>
<pre style="white-space:pre-wrap">&lt;PlaceOnLoop name=( &amp;string) host_chain=(2 &amp;integer) loop_begin=(&amp;integer) loop_end=(&amp;integer) minimize_toward_stub=(1&amp;bool) stubfile=(&amp;string) score_high=(score12 &amp;string) score_low=(score4L&amp;string) closing_attempts=(100&amp;integer) shorten_by=(&amp;comma-delimited list of integers) lengthen_by=(&amp;comma-delimited list of integers)/&gt;
</pre>
<p>currently only minimize_toward_stub is avaible.
closing attempts: how many kinematic-loop closure cycles to use.
shorten_by, lengthen_by: by how many residues to change the loop. No change is also added by default.
</p><p>At each try, a random choice of loop change will be picked and attempted. If the loop cannot close, failure will be reported.
</p><p>Demonstrated in JMB 413:1047
</p><p><br>
</p>
<a name="PlaceStub"></a><h4>PlaceStub</h4>
<p>Hotspot-based sidechain placement. This is the main workhorse of the hot-spot centric method for protein-binder design. A paper describing the method and a benchmark will be published soon. The "stub" (hot-spot residue) is chosen at random from the provided stub set. To minimize towards the stub (during placement), the user can define a series of movers (StubMinimize tag) that can be combined with a weight. The weight determines the strength of the backbone stub constraints that will influence the mover it is paired with. Finally, a series of user-defined design movers (DesignMovers tag) are made and the result is filtered according to final_filter. There are two main ways to use PlaceStub:<br>
</p><ol>
<p></p>
<li>PlaceStub (default). Move the stub so that it's on top of the current scaffold position, then move forward to try to recover the original stub position.
</li><li>PlaceScaffold. Move the scaffold so that it's on top of the stub. You'll keep the wonderful hotspot interactions, but suffer from lever effects on the scaffold side. PlaceScaffold can be used as a replacement for docking by deactivating the "triage_positions" option.
</li></ol>
<pre style="white-space:pre-wrap">&lt;PlaceStub name=(&amp;string) place_scaffold=(0 &amp;bool) triage_positions=(1 &amp;bool) chain_to_design=(2 &amp;integer) score_threshold=(0.0 &amp;Real) allowed_host_res=(&amp;string) stubfile=(&amp;string) minimize_rb=(0 &amp;bool) after_placement_filter=(true_filter &amp;string) final_filter=(true_filter &amp;string) max_cb_dist=(4.0 &amp;Real) hurry=(1 &amp;bool) add_constraints=(1 &amp;bool) stub_energy_threshold=(1.0 &amp;Real) leave_coord_csts=(0 &amp;bool) post_placement_sdev=(1.0 &amp;Real)&gt;
     &lt;StubMinimize&gt;
        &lt;Add mover_name=(&amp;string) bb_cst_weight=(10, &amp;Real)/&gt;
     &lt;/StubMinimize&gt;
     &lt;DesignMovers&gt;
        &lt;Add mover_name=(&amp;string) use_constraints=(1 &amp;bool) coord_cst_std=(0.5 &amp;Real)/&gt;
     &lt;/DesignMovers&gt;
     &lt;NotifyMovers&gt;
        &lt;Add mover_name=(&amp;string)/&gt;
     &lt;/NotifyMovers&gt;
&lt;/PlaceStub&gt;
</pre>
<ul>
<li>place_scaffold: use PlaceScaffold instead of PlaceStub. this will place the scaffold on the stub's position by using an inverse rotamer approach.
</li><li>triage_positions: remove potential scaffold positions based on distance/cst cutoffs. speeds up the search, but must be turned off to use place_scaffold=1 as a replacement for docking (that is, when placing the scaffold at positions regardless of the input structure). triage_positions=1 triages placements based on whether the hotspot is close enough (within max_cb_distance) and whether the hotspot's vectors align with those of the host position (with some tolerance).
</li><li>chain_to_design
</li><li>score_threshold
</li><li>allowed_host_res: A list of residues on the host scaffold where the stub may be placed. The list should be comma-seperated and may contain either rosetta indices (e.g. 123) or pdb indices (e.g. 123A). Note that allowed residues must still pass the triage step (if enabled) and other restrictions on which residues may be designed (e.g. not proline).
</li><li>stubfile: using a stub file other than the one used to make constraints. This is useful for placing stubs one after the other.
</li><li>minimize_rb: do we want to minimize the rb dof during stub placement? This will allow a previously placed stub to move a a little to accommodate the new stub. It's a good idea to use this with the previously placed stub adding its implied constraints.
</li><li>after_placement_filter: The name of a filter to be applied immediately after stub placement and StubMinimize movers, but before the DesignMovers run. Useful for quick sanity check on the goodness of the stub.
</li><li>final_filter: The name of a filter to be applied at the final stage of stub placement as the last test, after DesignMovers run. Useful, e.g., if we want a stub to form an hbond to a particular target residue.
</li><li>max_cb_dist: the maximum cb-cb distance between stub and potential host residue to be considered for placement
</li><li>hurry: use a truncated scorefxn for minimization. large speed increases, doesn't seem to be less accurate.
</li><li>add_constraints: should we apply the coordinate constraints to this stub?
</li><li>stub_energy_threshold: Decoys are only considered if the single-residue energy of the stub is below this value
</li><li> leave_coord_csts: should the coordinate constraints be left on when placement is completed successfully? This is useful if you plan on making moves after placement and you want the hotspot's placement to be respected. Note that designing a residue that has constraints on it is likely to yield crashes. You can use task operations to disallow that residue from designing.
</li><li> post_placement_sdev: relating to the item above. The lower the sdev (towards 0) the more stringent the constraint.
</li></ul>
<p>The available tracers are:
</p>
<ul>
<li>protocols.ProteinInterfaceDesign.movers.PlaceStubMover - light-io documentation of the run
</li><li>STATS.PlaceStubMover - statistics on distances and score values during placement
</li><li>DEBUG.PlaceStubMover - more io intensive documentation
</li></ul>
<p><strong>Submovers:</strong>
Submovers are used to determine what moves are used following stub placement. For example, once a stub has been selected, a StubMinimize mover can try to optimize the current pose towards that stub. A DesignMover can be used to design the pose around that stub. Using DesignMover submovers within PlaceStub (instead of RepackMinimize movers outside PlaceStub) allows one to have a "memory" of which stub has been used. In this way, a DesignMover can fail a filter without causing the trajectory to completely reset. Instead, the outer PlaceStub mover will select another stub, and the trajectory will continue.
<br>There are two types of sub movers that can be called within the mover. 
</p><ol>
<p></p>
<li><b>StubMinimize</b>
<br>Without defining this submover, the protocol will simply perform a rigid body minimization as well as sc minimization of previous placed stubs in order to minimize towards the stub.
Otherwise, a series of previously defined movers can be added, such as backrub, that will be applied for the stub minimization step. Before and after the list of stub minimize movers, there will be a rigid body minimization and a sc minimization of previously placed stubs. The bb_cst_weight determines how strong the constraints are that are derived from the stubs.
<ul>
<li>mover_name: a user previously defined design or minimize mover.
</li><li>bb_cst_weight: determines the strength of the constraints derived from the stubs. This value is a weight on the cb_force, so larger values are stronger constraints.
</li></ul>
<p>Valid/sensible StubMinimize movers are:
</p>
<ul>
<li>BackrubDD</li>
<li>LoopRemodel</li>
</ul>
</li><li><b>DesignMovers</b>
<br>Design movers are typically used once the stubs are placed to fill up the remaining interface, since placestub does not actually introduce any further design other than stub placement.
<ul>
<li>mover_name: a user previously defined design or minimize mover.
</li><li>use_constraints: whether we should use coordinate constraints during this design mover
</li><li>coord_cst_std: the std of the coordinate constraint for this mover. The coord constraints are harmonic, and the force constant, k=1/std. The smaller the std, the stronger the constraint
</li></ul>
<p>Valid/sensible DesignMovers are:
</p>
<ul>
<li>RepackMinimize</li>
</ul>
</li><li><b>NotifyMovers</b></li>
<p>Movers placed in this section will be notified not to repack the PlaceStub-placed residues. This is not necessary if placement movers are used in a nested (recursive) fashion, as the placement movers automatically notify movers nested in them of the hot-spot residues. Essentially, you want to make the downstream movers (you list under this section) aware about the placement decisions in this upstream mover. These movers will not be run at in this placestub, but will be subsequently aware of placed residues for subsequent use. Useful for running design moves after placestub is done, e.g., in loops. Put task awareness only in the deepest placestub mover (if PlaceStub is nested), where the final decisions about which residues harbour hot-spot residues is made.
&lt;/UL&gt;
</p></ol>
<p></p>
<a name="PlaceSimultaneously"></a><h4>PlaceSimultaneously</h4>
<p>Places hotspot residues simultaneously on a scaffold, rather than iteratively as in PlaceStub. It is faster therefore allowing more backbone sampling, and should be useful in placing more than 2 hotspots.
</p>
<pre style="white-space:pre-wrap">&lt;PlaceSimultaneously name=(&amp;string) chain_to_design=(2 &amp;Integer) repack_non_ala=(1 &amp;bool) optimize_fold_tree=(1 &amp;bool) after_placement_filter=(true_filter &amp;string) auction=(&amp;string) stub_score_filter=(&amp;string)/&gt;
     &lt;DesignMovers&gt;
        &lt;Add mover_name=(null_mover &amp;string) use_constraints=(1 &amp;bool) coord_cst_std=(0.5 &amp;Real)/&gt;
     &lt;/DesignMovers&gt;
     &lt;StubSets explosion=(0 &amp;integer) stub_energy_threshold=(1.0 &amp;Real)  max_cb_dist=(3.0 &amp;Real) cb_force=(0.5 &amp;Real)&gt;
        &lt;Add stubfile=(&amp; string) filter_name=(&amp;string)/&gt;
     &lt;/StubSets&gt;
     &lt;StubMinimize min_repeats_before_placement=(0&amp;Integer) min_repeats_after_placement=(1&amp;Integer)&gt;
       &lt;Add mover_name=(null_mover &amp;string) bb_cst_weight=(10.0 &amp;Real)/&gt;
     &lt;/StubMinimize&gt;
     &lt;NotifyMovers&gt;
       &lt;Add mover_name=(&amp;string)/&gt;
     &lt;/NotifyMovers&gt;
&lt;/PlaceSimultaneously&gt;
</pre>
<p>Most of the options are similar to PlaceStub above. Differences are mentioned below:
</p>
<ul>
<li> explosion: which chis to explode
</li><li> stub_energy_threshold: after placement and minimization, what energy cutoff to use for each of the hotspots.
</li><li> after_placement_filter: After all individual placement filters pass, this is called (might be redundant?)
</li><li> min_repeats: How many minimization repeats (over StubMinimize movers) after placement
</li><li> movers defined under NotifyMovers will not be allowed to change the identities or rotamers of their hot-spot residues beyond what PlaceSimultaneously has decided on. This would be useful for avoiding losing the hot-spot residues in design movers after placement.
</li><li> filters specified in the StubSets section may be set during PlaceSimultaneously's execution by PlaceSimultaneously. This allows filters to be set specifically for placed hot-spot residues. One such filter is AtomicContact.
</li><li> rb_stub_minimization: a StubMinimization mover that will be run before PlaceSimultaneously.
</li><li> auction: and Auction mover that will be run before PlaceSimultaneously.
</li><li> stub_score_filter: a StubScoreFilter that will be run before PlaceSimultaneously.
</li></ul>
<p>rb_stub_minimization, auction and stub_score_filter allow the user to specify the first moves and filtering steps of PlaceSimultaneously before PlaceSimultaneously is called proper. In this way, a configuration can be quickly triaged if it isn't compatible with placement (through Auction's filtering). If the configuration passes these filters and movers then PlaceSimultaneously can be run within loops of docking and placement, until a design is identified that produces reasonable ddg and sasa.
</p>
<a name="StubScore"></a><h4>StubScore</h4>
<p>This is actually a filter (and should go under FILTERS), but it is tightly associated with the placement movers, so it's placed here. A special filter that is associated with PlaceSimultaneouslyMover. It checks whether in the current configuration the scaffold is 'feeling' any of the hotspot stub constraints. This is useful for quick triaging of hopeless configuration.
</p>
<pre style="white-space:pre-wrap">&lt;StubScore name=(&amp;string) chain_to_design=(2 &amp;integer) cb_force=(0.5 &amp;Real)&gt;
  &lt;StubSets&gt;
     &lt;Add stubfile=(&amp;string)/&gt;
  &lt;/StubSets&gt;
&lt;/StubScore&gt;
</pre>
<p>Note that none of the flags of this filter need to be set if PlaceSimultaneously is notified of it. In that case, PlaceSimultaneously will set this StubScore filter's internal data to match its own.
</p>
<a name="ddG"></a><h4>ddG</h4>
<p>This mover is useful for reporting the total or per-residue ddgs in cases where you don't want to use the ddG filter for some reason.  (also, the ddg filter can't currently do per-residue ddgs).  Ddg scores are reported as string-real pairs in the job.  The total ddg score has the tag "ddg" and the each pre residue ddg has the tag "residue_ddg_n" where n is the residue number. 
</p>
<pre style="white-space:pre-wrap">&lt;ddG name=(&amp;string) jump=(1 &amp;integer) symmetry=(0 &amp;bool) per_residue_ddg=(0 &amp;bool) repack=(0 bool&amp;) scorefxn=("score12" &amp;string) /&gt;
</pre>
<a name="ContactMap"></a><h4>ContactMap</h4>
<p>Calculate and output contact maps for each calculated structure
</p>
<pre style="white-space:pre-wrap">&lt;ContactMap name="&amp;string" region1=( &amp;string) region2=( &amp;string) ligand=( &amp;string)  distance_cutoff=( 10.0 &amp;Real)  prefix=("contact_map_" &amp;string) reset_count=("true" &amp;string) models_per_file=(1 &amp;int) row_format=("false" &amp;string) / &gt;
</pre>
<pre>       - region1: region definition for region1 of  ContactMap in format '&lt;start&gt;-&lt;end&gt;' or '&lt;chainID&gt;'  defaults to 1-&lt;n_residue()&gt;
       - region2: region definition for region2 of  ContactMap
       - ligand: sequence position or chainID of ligand - all non-hydrogen atoms of the corresponding residue will be mapped against the CB atoms of region1(ignored if region2-tag is specified)
       - distance_cutoff: Maximum distance of two atoms so contacts count will be increased
       - prefix: Prefix for output_filenames
       - reset_count:  flag whether the count will be reset to 0 after the ContactMap was output to a file. if set to false, the same file will be updated every 'models_per_file'
                                  structures (only applies for n_struct&gt;1 when called with the Scripter)
       - models_per_file: defines after how many structures an output file should be generated  (no file will be created if equal to 0 or greater than n_struct&nbsp;!)
       - row_format: flag if output should be in row format rather than the default matrix format
</pre>
<a name="Ligand-centric_Movers"></a><h2>Ligand-centric Movers</h2>
<a name="Ligand_docking"></a><h3>Ligand docking</h3>
<p>These movers replace the executable for ligand docking and provide greater flexibility to the user in customizing the docking protocol.  An example XML file for ligand docking is found here (link forthcoming).  The movers below are listed in the order found in the old executable.
</p>
<a name="StartFrom"></a><h4>StartFrom</h4>
<pre style="white-space:pre-wrap">&lt;StartFrom name="&amp;string" chain="&amp;string"/&gt;
   &lt;Coordinates x=(&amp;float) y=(&amp;float) z=(&amp;float)/&gt;
&lt;/StartFrom&gt;</pre>
<p>Provide a list of XYZ coordinates.  One starting coordinate will be chosen at random and the specified chain will be recentered at this location.
</p>
<a name="Translate"></a><h4>Translate</h4>
<pre style="white-space:pre-wrap">&lt;Translate name="&amp;string" chain="&amp;string" distribution=[uniform|gaussian] angstroms=(&amp;float) cycles=(&amp;int)/&gt;</pre>
<p>The Translate mover is for performing a course random movement of a small molecule in xyz-space.  This movement can be anywhere within a sphere of radius specified by "angstroms".  The chain to move should match that found in the PDB file (a 1-letter code). "cycles" specifies the number of attempts to make such a movement without landing on top of another molecule.  The first random move that does not produce a positive repulsive score is accepted.  The random move can be chosen from a uniform or gaussian distribution.  This mover uses an attractive-repulsive grid for lightning fast score lookup.
</p>
<a name="Rotate"></a><h4>Rotate</h4>
<pre style="white-space:pre-wrap">&lt;Rotate name="&amp;string" chain="&amp;string" distribution=[uniform|gaussian] degrees=(&amp;int) cycles=(&amp;int)/&gt;</pre>
<p>The Rotate mover is for performing a course random rotation throughout all rotational degrees of freedom.  Usually 360 is chosen for "degrees" and 1000 is chosen for "cycles".  Rotate accumulates poses that pass an attractive and repulsive filter, and are different enough from each other (based on an RMSD filter).  From this collection of diverse poses, 1 pose is chosen at random. "cycles" represents the maximum # of attempts to find diverse poses with acceptable attractive and repulsive scores.  If a sufficient # of poses are accumulated early on, less rotations then specified by "cycles" will occur. This mover uses an attractive-repulsive grid for lightning fast score lookup.
</p>
<a name="SlideTogether"></a><h4>SlideTogether</h4>
<pre style="white-space:pre-wrap">&lt;SlideTogether name="&amp;string" chain="&amp;string"/&gt;</pre>
<p>The initial translation and rotation may move the ligand to a spot too far away from the protein for docking.  Thus, after an initial low resolution translation and rotation of the ligand it is necessary to move the small molecule and protein into close proximity.  If this is not done then high resolution docking will be useless.  Simply specify which chain to move.  This mover then moves the small molecule toward the protein 2 angstroms at a time until the two clash (evidenced by repulsive score).  It then backs up the small molecule.  This is repeated with decreasing step sizes, 1A, 0.5A, 0.25A, 0.125A.
</p>
<a name="HighResDocker"></a><h4>HighResDocker</h4>
<pre style="white-space:pre-wrap">&lt;HighResDocker name="&amp;string" repack_every_Nth=(&amp;int) scorefxn="string" movemap_builder="&amp;string" /&gt;</pre>
<p>The high res docker performs cycles of rotamer trials or repacking, coupled with small perturbations of the ligand(s).  The "movemap_builder" describes which side-chain and backbone degrees of freedom exist.  The Monte Carlo mover is used to decide whether to accept the result of each cycle.  Ligand and backbone flexibility as well as which ligands to dock are described by LIGAND_AREAS provided to INTERFACE_BUILDERS, which are used to build the movemap according the the XML option.
</p>
<a name="FinalMinimizer"></a><h4>FinalMinimizer</h4>
<pre style="white-space:pre-wrap">&lt;FinalMinimizer name="&amp;string" scorefxn="&amp;string" movemap_builder=&amp;string/&gt;</pre>
<p>Do a gradient based minimization of the final docked pose.  The "movemap_builder" makes a movemap that will describe which side-chain and backbone degrees of freedom exist.
</p>
<a name="InterfaceScoreCalculator"></a><h4>InterfaceScoreCalculator</h4>
<pre style="white-space:pre-wrap">&lt;InterfaceScoreCalculator name=(string) chains=(comma separated chars) scorefxn=(string) native=(string)/&gt;</pre>
<p>InterfaceScoreCalculator calculates a myriad of ligand specific scores and appends them to the output file.  After scoring the complex the ligand is moved 1000  away from the protein.  The model is then scored again.  An interface score is calculated for each score term by subtracting separated energy from complex energy.  If a native structure is specified, 4 additional score terms are calculated: 
</p>
<ol><li> ligand_centroid_travel.  The distance between the native ligand and the ligand in our docked model.
</li><li> ligand_radious_of_gyration.  An outstretched conformation would have a high radius of gyration.  Ligands tend to bind in outstretched conformations.
</li><li> ligand_rms_no_super.  RMSD between the native ligand and the docked ligand.
</li><li> ligand_rms_with_super.  RMSD between the native ligand and the docked ligand after aligning the two in XYZ space.  This is useful for evaluating how much ligand flexibility was sampled.
</li></ol>
<a name="Enzyme_design"></a><h3>Enzyme design</h3>
<a name="EnzRepackMinimize"></a><h4>EnzRepackMinimize</h4>
<p>EnzRepackMinimize, similar in spirit to RepackMinimize mover, does the design/repack followed by minimization of a protein-ligand (or TS model) interface with enzyme design style constraints (if present, see AddOrRemoveMatchCsts mover) using specified score functions and minimization dofs. Only design/repack or minimization can be done by setting appropriate tags. A shell of residues around the ligand are repacked/designed and/or minimized. If constrained optimization or cst_opt is specified, ligand neighbors are converted to Ala, minimization performed, and  original neighbor sidechains are placed back.
</p>
<pre style="white-space:pre-wrap">&lt;EnzRepackMinimize name="&amp;string" scorefxn_repack=(score12 &amp;string) scorefxn_minimize=(score12 &amp;string) cst_opt=(0 &amp;bool) repack_only=(0 &amp;bool) design=(0 &amp;bool) fix_catalytic=(0 &amp;bool) minimize_rb=(1 &amp;bool) minimize_bb=(0 &amp;bool) minimize_sc=(1 &amp;bool) minimize_lig=(0 &amp; bool) min_in_stages=(0 &amp;bool) backrub=(0 &amp;bool) cycles=(1 &amp;integer)/&gt;</pre>
<ul>
<li>scorefxn_repack: scorefunction to use for repack/design (defined in the SCOREFXNS section, default=score12)
</li><li>scorefxn_minimize: similarly, scorefunction to use for minimization (default=score12)
</li><li>cst_opt: perform minimization of enzdes constraints with a reduced scorefunction and in a polyAla background. (default= 0)
</li><li>repack_only: if true, only repack sidechains without changing sequence. (default =0)
</li><li>design: optimize sequence of residues spatially around the ligand (detection of neighbors need to be specified in the flagfile or resfile, default=0)
</li><li>minimize_bb: minimize back bone conformation of backbone segments that surround the ligand (contiguous neighbor segments of &gt;3 residues are automatically chosen, default=0)
</li><li>minimize_sc: minimize sidechains (default=1)
</li><li>minimize_rb: minimize rigid body orientation of ligand (default=1)
</li><li>minimize_lig: minimize ligand internal torsion degrees of freedom (allowed deviation needs to be specified by flag, default =0)
</li><li>min_in_stages: first minimize non-backbone dofs, followed by backbone dofs only, and then everything together (default=0)
</li><li>fix_catalytic: fix catalytic residues during repack/minimization (default =0)
</li><li>cycles: number of cycles of repack-minimize (default=1 cycle) (Note: In contrast to the enzyme_design application, all cycles use the provided scorefunction.)
</li><li>backrub:use backrub to minimize (default=0). 
</li></ul>
<a name="AddOrRemoveMatchCsts"></a><h4>AddOrRemoveMatchCsts</h4>
<p>Add or remove enzyme-design style pairwise (residue-residue) geometric constraints to/from the pose.  A cstfile specifies these geometric constraints, which can be supplied in the flags file (-enzdes:cstfile) or in the mover tag (see below). 
</p><p>The "-run:preserve_header" option should be supplied on the command line to allow the parser to read constraint specifications in the pdb's REMARK lines. (The "-enzdes:parser_read_cloud_pdb" also needs to be specified for the parser to read the matcher's CloudPDB default output format.)
</p>
<pre style="white-space:pre-wrap">&lt;AddOrRemoveMatchCsts name="&amp;string" cst_instruction=( "void", "&amp;string") cstfile="&amp;string" keep_covalent=(0 &amp;bool) accept_blocks_missing_header=(0 &amp;bool) fail_on_constraints_missing=(1 &amp;bool)/&gt;</pre>
<ul>
<li>cst_instruction: 1 of 3 choices - "add_new" (read from file), "remove", or "add_pregenerated" (i.e. if enz csts existed at any point previosuly in the protocol add them back) 
</li><li>cstfile: name of file to get csts from (can be specified here if one wants to change the constraints, e.g. tighten or relax them, as the pose progresses down a protocol.)
</li><li>keep_covalent: during removal, keep constraints corresponding to covalent bonds between protein and ligand intact (default=0). 
</li><li>accept_blocks_missing_header: allow more blocks in the cstfile than specified in header REMARKs (see enzdes documentation for details, default=0)
</li><li>fail_on_constraints_missing: When removing constraints, raise an error if the constraint blocks do not exist in the pose (default=1).
</li></ul>
<a name="PredesignPerturbMover"></a><h4>PredesignPerturbMover</h4>
<p>PredesignPerturbMover randomly perturbs a ligand in a protein active site. The input protein will be transformed to a polyalanine context for residues surrounding the ligand. A number of random rotation+translation moves are made and then accepted/rejected based on the Boltzmann criteria with a modified (no attractive) score function (enzdes_polyA_min.wts).
</p><p>PredesignPerturbMover currently will perturb only the last ligand in the pose (the last jump).
</p>
<pre>&lt;PredesignPerturbMover name=(&amp;string) trans_magnitude=(0.1 &amp;real) rot_magnitude=(2.0 &amp;real) dock_trials=(100 &amp;integer) /&gt;</pre>
<ul><li> dock_trials - the number of Monte Carlo steps to attempt
</li><li> trans_magnitude - how large (stdev of a gaussian) a random translation step to take in each of x, y, and z
</li><li> rot_magnitude - how large (stdev of a gaussian) a random rotational step to take in each of the Euler angles
</li></ul>
<a name="Ligand_design"></a><h3>Ligand design</h3>
<p>These movers work in conjunction with ligand docking movers.  An example XML file for ligand design is found here (link forthcoming).  These movers presuppose the user has created or acquired a fragment library.  Fragments have incomplete connections as specified in their params files.  Combinatorial chemistry is the degenerate case in which a core fragment has several connection points and all library fragments have only one connection point.
</p>
<a name="GrowLigand"></a><h4>GrowLigand</h4>
<pre style="white-space:pre-wrap">&lt;GrowLigand name="&amp;string" chain="&amp;string"/&gt;</pre>
<p>Randomly connects a fragment from the library to the growing ligand.  The connection point for connector atom1 must specify that it connects to atoms of connector atom2's type, and visa versa.
</p>
<a name="AddHydrogens"></a><h4>AddHydrogens</h4>
<pre style="white-space:pre-wrap">&lt;AddHydrogens name="&amp;string" chain="&amp;string"/&gt;</pre>
<p>Saturates the incomplete connections with H.  Currently the length of these created H-bonds is incorrect.  H-bonds will be the same length as the length of a bond between connector atoms 1 and 2 should be.
</p>
<a name="DNA_interface_Design_Movers"></a><h2>DNA interface Design Movers</h2>
<a name="DnaInterfacePacker"></a><h3>DnaInterfacePacker</h3>
<pre>&lt;DnaInterfacePacker name=(&amp;string) scorefxn=(&amp;string) task_operations=(&amp;string,&amp;string,&amp;string) binding=(0, &amp;bool) base_only=(false, &amp;bool) minimize=(0, &amp;bool) probe_specificity=(0, &amp;bool) reversion_scan=(false, &amp;bool)/&gt;
</pre>
<ul><li> binding: calculate binding energy
</li><li> base_only: consider only interaction with the DNA bases
</li><li> minimize: minimize protein side chains at the interface
</li><li> probe_specificity: calculate binding energy of designed protein for alternative DNA targets and calculate a specificity score
</li><li> reversion_scan: revert mutations that do not contribute to the specificity score
</li></ul>
<a name="Currently_Undocumented"></a><h2>Currently Undocumented</h2>
<p>The following Movers are available through RosettaScripts, but are not currently documented. See the code (particularly the respective parse_my_tag() and apply() functions) for details. (Some may be undocumented as they are experimental/not fully functional.)
</p>
<ul><li> BackboneSampler
</li><li> BackrubSidechain
</li><li> BluePrintBDR
</li><li> CircularPermutation
</li><li> CompoundTranslate
</li><li> ConformerSwitchMover
</li><li> DesignProteinBackboneAroundDNA
</li><li> DnaInterfaceMinMover
</li><li> DnaInterfaceMultiStateDesign
</li><li> Dssp
</li><li> EnzdesRemodelMover
</li><li> ExtendedPoseMover
</li><li> FavorNonNativeResidue
</li><li> FlxbbDesign
</li><li> HotspotHasher
</li><li> LigandDesign
</li><li> LoopHash
</li><li> LoopMover_Refine_CCD
</li><li> MatcherMover
</li><li> MinimizeBackbone
</li><li> MotifDnaPacker
</li><li> RandomConformers
</li><li> RemodelLoop
</li><li> RotamerRecoveryMover
</li><li> SavePoseMover
</li><li> ScoreMover
</li><li> SeparateDnaFromNonDna
</li><li> SetupHotspotConstraints
</li><li> StapleMover
</li><li> Transform
</li></ul>


<br></div>
<!-- Served by plug in 0.44 secs. -->
</body></html>
